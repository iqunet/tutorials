<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="/tutorials/feed.xml" rel="self" type="application/atom+xml" /><link href="/tutorials/" rel="alternate" type="text/html" /><updated>2024-08-29T15:47:14-05:00</updated><id>/tutorials/feed.xml</id><title type="html">Tutorials</title><subtitle>iQunet offers ready-to-use products for your digitalization projects, ensuring a quick rollout of your monitoring solutions.  We also support custom engineering requests to meet your specific needs.</subtitle><author><name>{&quot;avatar&quot;=&gt;&quot;/assets/images/iqunet_logo_bgwhite.svg&quot;, &quot;links&quot;=&gt;[{&quot;label&quot;=&gt;&quot;iQunet.com&quot;, &quot;icon&quot;=&gt;&quot;fas fa-fw fa-house&quot;, &quot;url&quot;=&gt;&quot;https://iqunet.com&quot;}, {&quot;label&quot;=&gt;&quot;LinkedIn&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-linkedin&quot;, &quot;url&quot;=&gt;&quot;https://linkedin.com/company/iqunet/&quot;}, {&quot;label&quot;=&gt;&quot;YouTube&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-youtube&quot;, &quot;url&quot;=&gt;&quot;https://www.youtube.com/channel/UCOPGTm7iW8Xh6ZJP8UBq_nQ&quot;}, {&quot;label&quot;=&gt;&quot;GitHub&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-github&quot;, &quot;url&quot;=&gt;&quot;https://iqunet.github.io/tutorials&quot;}]}</name></author><entry><title type="html">Anomaly Detection with MEMS Vibration Sensors and Machine Learning - Part 1/3 Introduction</title><link href="/tutorials/blog/anomaly-detection-vibration-part1/" rel="alternate" type="text/html" title="Anomaly Detection with MEMS Vibration Sensors and Machine Learning - Part 1/3 Introduction" /><published>2024-08-18T00:00:00-05:00</published><updated>2024-08-18T00:00:00-05:00</updated><id>/tutorials/blog/anomaly-detection-vibration-part1</id><content type="html" xml:base="/tutorials/blog/anomaly-detection-vibration-part1/"><![CDATA[<p><img src="/tutorials/assets/images/recycling_plant.jpg" alt="Recycling Plant Artists Impression" width="500px" /></p>

<h3 id="scope-and-tldr">Scope and TL;DR</h3>
<p>This post explores how <strong>wireless vibration sensors</strong> and machine learning
techniques are used for <strong>anomaly detection</strong> in industrial shaker screens.
By monitoring vibration data and using deep-learning models, various types of
mechanical faults can be detected at an early stage.</p>

<p class="description_3">This is the first part in a three-part series.<br />
<a href="/tutorials/blog/anomaly-detection-vibration-part2">Part 2: Anomaly Detection with Autoencoders</a><br />
<a href="/tutorials/blog/anomaly-detection-vibration-part3">Part 3: Real-world Vibratory Screen Data</a></p>

<p>We cover the technical setup and data postprocessing using autoencoders
(part 2), which are the key elements for reliable and fully automated fault
detection.</p>

<p>Finally, based on real-world data collected during an 7-month long data
collection example from a household waste processing plant in the Benelux, the
reader will understand both the strengths and weaknesses of the system (part 3).</p>

<p><img src="/tutorials/assets/images/vibration-to-anomaly.jpg" alt="Teaser Banner Vibration Sensors to Anomaly Score" width="100%" style="box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);" /></p>

<p>This read is targeted at both the vibration expert and the casual reader
interested in gaining better insight in the practical applications of machine
learning, beyond the hype that has surrounded it in recent years.</p>

<h3 id="introduction">Introduction</h3>
<p>Waste management plants rely on long serial processing lines. Failures in any
pivotal stage may cause severe capacity loss due to the limited redundancy. This
makes some level of monitoring targeted towards machine health and predictive
maintainance crucial to avoid unplanned downtimes and the cost that inevitably
comes with it.</p>

<p>See “<em>How does the post-separation process work?</em>” by
<a class="external" href="https://www.avr.nl/en/optimal-process/nascheidingsinstallatie-nsi" target="_blank">AVR.nl
</a> for additional photos.</p>

<p><img src="/tutorials/assets/images/vibration-avr-separation.svg" alt="Schematic Representation of the AVR Separation Plant" width="100%" style="box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);" /></p>
<figcaption>
  Figure 3: Overview of the Household Waste Separation Process
  (click to enlarge) [credits: AVR].
</figcaption>

<p>While <strong>digital PLCs</strong> are in the control of the pipeline and can already
detect the most <strong>acute faults</strong> in realtime, machine manufacturers treat
predictive monitoring mostly as an afterthought, leaving it to the maintanance
staff to handle unexpected random failures. However, in unhealthy environments
filled with dust, humidity, and noise, routine manual inspections are not
practical.</p>

<p><img src="/tutorials/assets/images/vibration-dust.jpg" alt="Unhealthy Environment with Dust" width="500px" /></p>
<figcaption>
  Figure 4: Unhealthy environment at a waste processing plant &mdash;<br />
  Accumulation of dust on the receiver module after several weeks of operation.
</figcaption>

<p>In this blogpost, we will show that ruggedized <strong>wireless vibration sensors</strong>
and machine learning in the data postprocessing chain provide us with 
<strong>consistent health updates</strong> at a regular interval, enabling early detection
of issues. We shall cover the technical setup, the data processing, and the
machine learning which automate the anomaly detection in noisy environments.</p>

<blockquote>
  <p><em>Noisy, in this case, refers to the sensor signal, which is polluted with
unwanted vibrations from the production process itself, in addition to the
machine defects we are trying to detect here.</em></p>
</blockquote>

<hr />

<h3 id="monitoring-vibration-screens">Monitoring Vibration Screens</h3>

<p>Monitoring vibrating conveyor equipment in waste management plants presents
unique challenges. These plants are large, and network infrastructure or good
cellular coverage is often lacking. Installing <strong>cabling across large sites</strong> is
not only <strong>expensive</strong> but also prone to failures. This is especially true for
machines that experience significant vibrations.</p>

<p>One example such an is a <strong>vibratory screen</strong>, which pre-sorts the household
waste material on size before it undergoes optical sorting. In the optical
sorter, spectral cameras detect different materials, and pressurized air is
then used to further separate individual pieces into different output flows.</p>

<p>See “<em>SPALECK: Recycling Waste Screens</em>”
<a class="external" href="https://www.spaleck.eu/screening-machines" target="_blank">[spaleck.eu]
</a>.</p>

<p><img src="/tutorials/assets/images/vibration-vibratory-screen.jpg" alt="Vibratory Screen with Vibration Sensor Location" width="100%" style="box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);" /></p>
<figcaption>
  Figure 5: Vibratory Screen with the location of the Vibration Sensor
  [image credit: SPALECK].
</figcaption>

<p>These vibratory screens, driven by a synchronous motor that powers an eccentric
axle with counterweight, pose several challenges:</p>

<ul>
  <li>
    <p><strong>Large Displacements:</strong> Translational displacements of up to 10 cm make not
only the shaker itself prone to considerable stresses, but also any wired
sensor setup will be susceptible to both <strong>connector wear and cable fatigue</strong>
in the long term.</p>
  </li>
  <li>
    <p><strong>Regular Maintenance:</strong> Parts of these machine are frequently disassembled
for maintenance. It is preferred that any sensors should be as non-intrusive as
possible during such manipulations. This ensures a <strong>consistent sensor location
and orientation</strong> and improves the accuracy of the machine learning algorithms.</p>
  </li>
</ul>

<p>Given the challenges of monitoring shaker machines, the customer here opted
for wireless sensors to avoid the above issues.</p>

<video width="300px" controls="" loop="" autoplay="" muted="" style="margin-left: 1em;">
  <source src="/tutorials/assets/videos/vibration-screen-render.mp4" type="video/mp4" />
  Your browser does not support the video tag.
</video>
<figcaption>figure 6: Video Demonstrating Sensor Placement and the Challenging
  Conditions on a Shaker Screen in a Waste Processing Plant.</figcaption>

<p>To ensure that routine maintenance tasks can be performed without disturbing
the sensors, they were installed 40 cm away from the ideal location.</p>

<p>The sensors are located on the machine frame, instead of directly on the bearing
housing of the eccentric axle, which  inevitably reduces the sensitivity to
high-frequency bearing faults. This highlights the gap between ideal lab
conditions and a typical installation.</p>

<p>So factors that need to be considered include:</p>

<ul>
  <li>
    <p><strong>Signal Propagation:</strong> The sensor’s non-ideal placement introduces multiple
wave propagation boundaries (i.e. transitions between materials), which
attenuate and reflect high-frequency signals. This makes any measurements above
10 kHz, including ultrasonic frequencies, costly and of limited benefit.</p>
  </li>
  <li>
    <p><strong>Unsuitability of RMS Sensors:</strong> For simple RMS sensors, the fault signals
will be masked by process noise. This makes them ineffective for vibratory
screens except for the most obvious late-stage catastrophic failures (see part 3).</p>
  </li>
</ul>

<hr />

<h3 id="mems-accelerometers">MEMS Accelerometers</h3>

<p>Given the above prerequisites, triaxial MEMS-based wireless vibration sensors
are an ideal choice.</p>

<p><img src="/tutorials/assets/images/vibration-mems-die.jpg" alt="Microphotograph of a MEMS Accelerometer Die" width="500px" style="margin-left: 1em;" /></p>
<figcaption>
  Figure 7: Microphotograph (2x2mm) of a MEMS Accelerometer (without the ASIC processor).
  <br /> Hollocher et al., "A Very Low Cost, 3-axis, MEMS Accelerometer for
  Consumer Applications," 2009. 
  <a class="external" href="https://www.researchgate.net/publication/224107749" target="_blank">[researchgate.net]
  </a>.
</figcaption>

<p>Fully integrated <strong>MEMS vibration sensors</strong> (micro-electromechanical system)
detect acceleration by measuring changes in capacitance (distance) between a
fixed electrode and a suspended <strong>on-chip proof mass</strong>. The variations in
capacitance are then digitized by the ASIC postprocessor embedded in the same
<a class="external" href="https://en.wikipedia.org/wiki/System_in_a_package" target="_blank">SiP package
</a>
and converted into their corresponding acceleration values.</p>

<p>Characteristics of MEMS:</p>

<ul>
  <li>
    <p><strong>Robustness:</strong> Highly durable and well-suited for long-term use in harsh
environments. Piezo accelerometers on the other hand, have superior noise
characteristics but are more prone to material failures of the ceramic sensing
elements and need more careful handling to maintain their calibrated
sensitivity.</p>
  </li>
  <li>
    <p><strong>Frequency Response:</strong> MEMS sensors capture vibrations up to a few kHz(*) in
three axes. This allows for spectral separation of process noise and fault
frequencies, so we can tune for the optimal the signal-to-noise ratio and
fault sensitivity.<br />
(* the installed sensors have a Nyquist -3dB bandwidth of +/-1KHz)</p>
  </li>
</ul>

<p><img src="/tutorials/assets/images/vibration-IVIB161010-ACC3-016-RBW-performance.png" alt="Noise Performance of the iQunet IVIB161010-ACC3-016 Accelerometer" width="90%" style="margin-left: 1em; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);" /></p>
<figcaption>
  Figure 8: Peak and Noise Performance of the iQunet IVIB161010-ACC3-016
  Accelerometer.
  <br />Detailed background on Frequency Response and RBW performance figures
  <a class="external" href="https://www.analog.com/media/en/analog-dialogue/volume-51/number-3/articles/mems-vibration-monitoring-acceleration-to-velocity.pdf" target="_blank">here
  </a>.
</figcaption>

<p>Advantages of wireless sensors:</p>

<ul>
  <li>
    <p><strong>Wireless Range:</strong> With a range of 20 to 50 meters, wireless sensors
eliminate the need for fragile and expensive cabling. Downside is the need for
battery replacement every 20-50,000 spectral measurements.</p>
  </li>
  <li>
    <p><strong>Cost:</strong> Each vibratory screen is equipped with 4 triaxial sensors.
Switching to piezoelectric sensors would significantly increase costs, tripling
the expense for the sensor elements alone compared to the total cost of the
complete wireless MEMS-based system.</p>
  </li>
</ul>

<p><img src="/tutorials/assets/images/vibration-wired-bridge.jpg" alt="Wireless Bridge for IEPE Vibration Sensors" width="90%" style="margin-left: 1em; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);" /></p>
<figcaption>
  Figure 9: Despite offering better sensitivity, a wireless IEPE bridge, with
  its additional cabling, is not a viable alternative to the existing 4x
  wireless MEMS triax sensors on the vibratory screen.
</figcaption>

<p>In the next chapters, we will discuss how the sensor data is post-processed
and used to align otherwise unplanned downtime with scheduled maintenance tasks,
effectively reducing standstills to virtually 0 excess downtime.</p>

<hr />

<p><a href="/tutorials/blog/anomaly-detection-vibration-part2">Part 2: Anomaly Detection with Autoencoders</a></p>]]></content><author><name>{&quot;avatar&quot;=&gt;&quot;/assets/images/iqunet_logo_bgwhite.svg&quot;, &quot;links&quot;=&gt;[{&quot;label&quot;=&gt;&quot;iQunet.com&quot;, &quot;icon&quot;=&gt;&quot;fas fa-fw fa-house&quot;, &quot;url&quot;=&gt;&quot;https://iqunet.com&quot;}, {&quot;label&quot;=&gt;&quot;LinkedIn&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-linkedin&quot;, &quot;url&quot;=&gt;&quot;https://linkedin.com/company/iqunet/&quot;}, {&quot;label&quot;=&gt;&quot;YouTube&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-youtube&quot;, &quot;url&quot;=&gt;&quot;https://www.youtube.com/channel/UCOPGTm7iW8Xh6ZJP8UBq_nQ&quot;}, {&quot;label&quot;=&gt;&quot;GitHub&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-github&quot;, &quot;url&quot;=&gt;&quot;https://iqunet.github.io/tutorials&quot;}]}</name></author><category term="blog" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Anomaly Detection with MEMS Vibration Sensors and Machine Learning - Part 3/3 Bearing Damage Detection</title><link href="/tutorials/blog/anomaly-detection-vibration-part3/" rel="alternate" type="text/html" title="Anomaly Detection with MEMS Vibration Sensors and Machine Learning - Part 3/3 Bearing Damage Detection" /><published>2024-08-18T00:00:00-05:00</published><updated>2024-08-18T00:00:00-05:00</updated><id>/tutorials/blog/anomaly-detection-vibration-part3</id><content type="html" xml:base="/tutorials/blog/anomaly-detection-vibration-part3/"><![CDATA[<p><img src="/tutorials/assets/images/recycling_plant.jpg" alt="Recycling Plant Artists Impression" width="200px" /></p>

<p class="description_3">This is the third part in a three-part series.<br />
<a href="/tutorials/blog/anomaly-detection-vibration-part1">Part 1: Sensors in a Waste Processing Plant</a><br />
<a href="/tutorials/blog/anomaly-detection-vibration-part2">Part 2: Anomaly Detection with Autoencoders</a></p>

<h3 id="real-world-vibratory-screen-data">Real-world Vibratory Screen Data</h3>

<p>Figure 23 shows the autoencoder loss of a vibratory screen, based on 4,400
   measurements (3x8192 samples/meas) collected from a triax MEMS sensor between
   February and August 2024 on a vibratory screen as depicted in Figure 5
   (see Part 1).<br />
   The monitored period spans a period of 7 months of measurements and
   telemetry data with an estimated 70% of remaining battery capacity.</p>

<p>The historical data reveals the progression of a bearing fault over time:</p>

<ul>
  <li>Training data from February to March (600 measurements)</li>
  <li>Signs of <strong>initial damage</strong> become detectable around March 24 (T-70d)</li>
  <li>Further <strong>deterioration</strong> (stage-3) from May 22 onwards (T-11d)</li>
  <li><strong>Critical damage</strong> (stage-4 bearing fault) on June 2 (T)</li>
  <li>The bearing was <strong>replaced</strong> on June 17 (T+15d)</li>
</ul>

<p><img src="/tutorials/assets/images/vibration-screen3131-losses.svg" alt="Autoencoder loss history graph showing bearing fault progress" width="100%" style="margin-left: 0em;" /></p>
<figcaption>
     Figure 23: Autoencoder loss (anomaly) showing the progression of a bearing
     fault in a vibratory screen. While unsupervised learning does not reveal
     the root cause, it provides an early detection system and allows to track
     the fault progression hour-by-hour with little effort.
   </figcaption>

<p>Beyond the bearing failure, the data also shows a new increase in the anomaly
   level on August 8 (far right side fig. 23). This rise has been confirmed to
   be caused by a bent shaft, which was scheduled for replacement during the
   upcoming maintenance cycle.</p>

<p><img src="/tutorials/assets/images/vibration-bearing-photo.jpg" alt="Photo after removing the damaged bearing" width="480px" style="margin-left: 1em;" /></p>
<figcaption>
     Figure 24: Photograph of the damaged bearing upon removal on June 17.
   </figcaption>

<h4 id="limitations-of-rms-only-sensors">Limitations of RMS-only sensors</h4>

<p>Figure 25 illustrates the lack of sensitivity of an RMS-only sensor for
   bearing fault detection. Due to the in-band process noise, the fault’s
   energy stays undetectable until the very last stages, when it rises above
   the total integrated noise floor. Relying only on time-domain data or simple
   RMS thresholds is thus insufficient for early fault warnings.</p>

<p><img src="/tutorials/assets/images/vibration-screen3131-rms.svg" alt="RMS historian plot only reveals stage-4 bearing faults" width="100%" style="margin-left: 0em;" /></p>
<figcaption>
     Figure 25: Unless specifically tuned to the specific fault frequencies,
     the RMS aggregate is only sensitive to last stage of a bearing failure.
   </figcaption>

<h4 id="spectral-heatmap">Spectral Heatmap</h4>

<p>To review and understand the ML results, we introduce the spectral heatmap.
   In this plot, the horizontal x-axis represents measurement date, and the
   vertical slices (y-axis) represents the frequency spectrum of 1 single
   measurement (z-axis). Similar to the STFT, the energy in the spectrum is
   represented by a color map, with dark blue indicating the lowest magnitude
   and yellow the highest peaks.</p>

<p><img src="/tutorials/assets/images/vibration-screen3131-heatmap.svg" alt="Vibratory screen spectral heatmap from February to August 2024" width="100%" style="margin-left: 0em;" /></p>
<figcaption>
     Figure 24: Photograph of the damaged bearing upon removal on June 17.
   </figcaption>

<p><strong>Upper part of the spectrum</strong><br />
   In the spectrum above 300Hz (bin &gt;1500), we can observe some early stage
   indicators of an upcoming change in the behaviour of the machine. The first
   warning (‘initial damage’) appears around 10 weeks before the critical damage
   of the bearing, then it disappears temperorarily because of routine
   maintainance.</p>

<p>Around 11 days before the bearing failure it appears again. In the final
   stage of the bearing damage, we can see the fault spectrum spread out over
   all frequency bands, which is the well-known indicator for stage-4 bearing
   damage.</p>

<p><strong>Lower part of the spectrum</strong><br />
   Figure 24 also shows that most of the process noise is concentrated around
   the fundamental drive frequency and its harmonics. For example, bin 500
   (97Hz) shows the process noise modulated onto the 2nd harmonic (asynchronous
   motor at mains frequency of 50Hz with 3% slip).</p>

<p>In the lower part of the spectrum, the harmonics originate partially from
   the inevitable slight imbalance combined with the very rigid structure of
   the screen itself and partially due to the nonlinear behaviour of the
   screen’s separator structures. Apart from the static load on the bearing,
   the high forces due to the rigid bearing and the dynamic imbalance are the
   main cause of a reduced service life of the eccentric shaft bearing.</p>

<p>For an in-depth analysis, see
   <a href="https://www.researchgate.net/publication/373367839" target="_blank">
     [researchgate.net]
   </a>:
   <img src="/tutorials/assets/images/vibration-screen-model-paper.png" alt="Diagnostics of Bolted Joints in Vibrating Screens Based on a Multi-Body Dynamical Model" width="100%" style="margin-left: 0em;" /></p>

<hr />

<h4 id="mitigation-of-false-positives">Mitigation of False Positives</h4>

<p>While the spectral heatmap provides detailed insights into the operational
   behavior of the vibratory screen, visually inspecting a heatmap for each
   sensor is impractical on a daily basis for more than a few sensor nodes.</p>

<p>The key advantage of the “STFT + autoencoder + loss function” approach is
   its ability to project complex sensor signals onto a single numeric “anomaly
   score” via a nonlinear mapping.</p>

<p>The anomaly score then allows us to use a simple, temperature-like threshold
   based on historical anomaly values. This eliminates the need to manually set
   alarm levels for each individual frequency subrange. This is especially true
   for equipment that comes with little a-priori information, such as small
   ubiquitous equipment like pumps, conveyor belts, or fans.</p>

<p><img src="/tutorials/assets/images/vibration-canvas-iqunet.jpg" alt="Screenshot of the Canvas plugin of the iQunet Edge server" width="100%" style="box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);" /></p>
<figcaption>
     Figure 25: The Canvas plugin of the iQunet edge server allows the user
     to build custom dashboards. In this screenshot, the page shows the 50%
     median rolling estimate of the autoencoder anomaly score for 4 sensors
     on the vibratory screen. <br /><i>[Click image to enlarge]</i>
   </figcaption>

<p>To minimize false alarms, the output of the loss detector is smoothed using
   a rolling window quantile estimator before being compared to the threshold.
   A lower quantile with a larger window reduces the likelihood of false alarms
   but slows response time. Conversely, a higher quantile increases sensitivity
   at the expense of more false positives. Using multiple quantiles with a
   single threshold provides alarms with varying severity levels.</p>

<p><img src="/tutorials/assets/images/vibration-anomaly-quantiles.png" alt="Anomaly score with 5%, 50% and 95% rolling window quantiles" width="517px" style="box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);" /></p>
<figcaption>
     Figure 26: iQunet dashboard showing the 5%, 50% and 95% rolling window
     anomaly anomaly score quantiles. The same data is also available in
     OPC-UA (/MQTT) for export to any factory SCADA (/IoT) platform.
   </figcaption>

<p>When the alarm is triggered, the anomaly score continues to provide insights
   into the stability of the anomaly: we can now see of how rapidly the machine
   is deviating from its operational baseline. It provides useful data for how
   fast an intervention must be planned.</p>

<hr />

<h3 id="conclusion">Conclusion</h3>

<p>Wireless vibration sensors combined with machine learning provide a powerful
   solution for day-to-day anomaly detection in industrial screens. By
   continuously monitoring machine behavior and processing data through
   deep-learning ML models, emerging random faults can be detected before they
   become catastrophic. Leveraging the strength of big data tips the scale in
   favor of MEMS technology, even with some reduced sensitivity/bandwidth
   compared to piezo sensors.</p>

<p>This predictive approach minimizes unplanned downtime, and allows to align
   repairs with the scheduled maintenance. The ability to automatically
   detect complex issues without relying on manual inspections or preset
   thresholds highlights the potential of integrating machine learning into
   industrial maintenance strategies, bringing the required level of
   understanding from expert vibration analist to anyone with a good technical
   background.</p>

<video width="90%" controls="" loop="" autoplay="" muted="" style="margin-left: 1em;">
     <source src="/tutorials/assets/videos/vibration-iqunet-ads.mp4" type="video/mp4" />
     Your browser does not support the video tag.
   </video>

<hr />

<p>For more detailed technical insights and support, explore our
<a href="https://iqunet.com/resources/">documentation</a> and
<a href="https://iqunet.com/resources/case-studies/case-study-1-international-airport/">case studies</a>,
or contact our <a href="https://iqunet.com/contact/">support team</a>.</p>]]></content><author><name>{&quot;avatar&quot;=&gt;&quot;/assets/images/iqunet_logo_bgwhite.svg&quot;, &quot;links&quot;=&gt;[{&quot;label&quot;=&gt;&quot;iQunet.com&quot;, &quot;icon&quot;=&gt;&quot;fas fa-fw fa-house&quot;, &quot;url&quot;=&gt;&quot;https://iqunet.com&quot;}, {&quot;label&quot;=&gt;&quot;LinkedIn&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-linkedin&quot;, &quot;url&quot;=&gt;&quot;https://linkedin.com/company/iqunet/&quot;}, {&quot;label&quot;=&gt;&quot;YouTube&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-youtube&quot;, &quot;url&quot;=&gt;&quot;https://www.youtube.com/channel/UCOPGTm7iW8Xh6ZJP8UBq_nQ&quot;}, {&quot;label&quot;=&gt;&quot;GitHub&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-github&quot;, &quot;url&quot;=&gt;&quot;https://iqunet.github.io/tutorials&quot;}]}</name></author><category term="blog" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Anomaly Detection with MEMS Vibration Sensors and Machine Learning - Part 2/3 Deep Learning</title><link href="/tutorials/blog/anomaly-detection-vibration-part2/" rel="alternate" type="text/html" title="Anomaly Detection with MEMS Vibration Sensors and Machine Learning - Part 2/3 Deep Learning" /><published>2024-08-18T00:00:00-05:00</published><updated>2024-08-18T00:00:00-05:00</updated><id>/tutorials/blog/anomaly-detection-vibration-part2</id><content type="html" xml:base="/tutorials/blog/anomaly-detection-vibration-part2/"><![CDATA[<p><img src="/tutorials/assets/images/recycling_plant.jpg" alt="Recycling Plant Artists Impression" width="200px" /></p>

<p class="description_3">This is the second part in a three-part series.<br />
<a href="/tutorials/blog/anomaly-detection-vibration-part1">Part 1: Sensors in a Waste Processing Plant</a><br />
<a href="/tutorials/blog/anomaly-detection-vibration-part3">Part 3: Real-world Vibratory Screen Data</a></p>

<h3 id="sensor-data-processing-and-machine-learning">Sensor Data Processing and Machine Learning</h3>

<p>The MEMS-based wireless vibration sensors (IVIB161010-ACC3-016) gather detailed,
day-to-day data containing info about the vibratory screen’s behavior (see part 1).</p>

<p>Each sensor captures three-axis vibration snapshots every 20 minutes
(configurable) at a sampling rate of 3200Hz (also configurable). A measurement,
consisting of up to 25,000 samples, is wirelessly transferred to a central edge
server equipped with an embedded historian database.</p>

<p><img src="/tutorials/assets/images/vibration-opcua-historian.png" alt="OPC-UA client showing historian vibration data." width="95%" style="margin-left: 1em;" /></p>
<figcaption>
  Figure 10: Up to 25GB of raw vibration data is stored in the OPC-UA historian
  database, which is used to train a deep learning model of the machine's
  behavior across different operating conditions.
  <br /><i>(image: UaExpert OPC-UA client.
  <a class="external" href="https://www.unified-automation.com/products/development-tools/uaexpert.html" target="_blank">[link]</a>)</i>
</figcaption>

<p>The iQunet edge server includes a TensorFlow processor for machine learning
inference, along with a customizable dashboard, making it a complete standalone
solution. For compatibility with third-party applications, the software also
comes with an OPC-UA server and MQTT publishing client, enabling real-time
visualization on the most common SCADA platforms (Kepware, Ignition, Siemens
SIMATIC, etc.) and cloud-based IoT systems.</p>

<p><img src="/tutorials/assets/images/vibration-dashboard-322-9944.png" alt="Screenshot of the embedded web interface of the iQunet edge server." width="95%" style="margin-left: 1em;" /></p>
<figcaption>
  Figure 11: The iQunet edge server comes with an embedded web interface and
  supports third-party software integration through OPC-UA, MQTT, and GraphQL.
  Both raw vibration data and post-processed derived metrics such as RMS,
  velocity and ML anomaly levels are exposed by all interfaces.
  [image: iQunet] <br /><i>(click to enlarge)</i>.
</figcaption>

<h3 id="from-raw-data-to-actionable-insights">From Raw Data to Actionable Insights</h3>

<p>The raw vibration data (i.e. acceleration time series vectors) collected by the
sensors undergoes several preprocessing steps to extract several aggregate and
more complex signal transformations, discussed below:</p>

<h4 id="prefiltering-data-streams-and-domains">Prefiltering, Data Streams and Domains</h4>

<p><strong>Prefiltering</strong><br />
   While some types of piezo sensors can directly generate high dynamic range
   velocity signals at very low frequencies using a charge-mode amplifier, most
   sensors types are acceleration-based. This means that the output needs to be
   integrated from m/s<sup>2</sup> to m/s to derive the velocity signal.</p>

<p>MEMS sensors are no different in this matter and are also acceleration based.
   Their output signal contains a large dc-signal (the gravitation component)
   which needs to be removed before the conversion to velocity.</p>

<blockquote>
  <p><strong>Expert Insights</strong><br />
Filtering is a complex mathematical process, similar to the preamp
stabilization time in piezo sensors. It is important to ensure that the
high rejection ratio of a highpass filter does not introduce ripple or
phase errors, as these can distort the time-domain signal and also cause
significant drift when integrating from acceleration to velocity. Linear
phase-filters, such as multi-stage digital FIR filters, are typically
used to address these challenges.</p>
</blockquote>

<p><img src="/tutorials/assets/images/vibration-linear-phase-filter.jpg" alt="Removing the dc-offset with a linear-phase filter." width="95%" style="margin-left: 1em;" /></p>
<figcaption>
     Figure 12: To integrate acceleration data into a velocity signal, the
     dc-offset must be removed to avoid drift in the integrated output. A
     linear-phase higpass filter, such as a Biquad FIR filter, is essential to
     preserve signal integrity during this process. In contrast, a
     nonlinear-phase filter, like the Chebyshev IIR filter, introduces severe
     phase distortion.
   </figcaption>

<p><strong>Data Streams</strong><br />
   Once the dc-offset is removed, the data is converted into several useful
   information streams in the edge server, including:</p>

<ul>
  <li><strong>Acceleration and velocity</strong></li>
  <li><strong>RMS and Kurtosis aggregate values</strong></li>
  <li><strong>Time and frequency domain views</strong></li>
</ul>

<p>These are some of the basic tools used by vibration experts to determine
   the state of the machine, and in more advance cases, also the origin of a
   fault, such as a loose mount or a bearing fault.<br />
   Other tools, such as enveloping demodulation, further postprocess the signal,
   primarily to represent the same data in a format or domain that is more
   easily understood by the human eye.</p>

<p><img src="/tutorials/assets/images/vibration_processing_flow.png" alt="Processing flow of vibration data in the edge server." width="95%" style="margin-left: 1em;" /></p>
<figcaption>
  Figure 13: Raw vibration data post-processing flows in the edge server. RMS
  data is the least sensitive for fault detection. Frequency plots and heatmaps
  are the preferred methods for experts. Machine learning-based anomaly
  detection combines the simplicity of RMS thresholds with the sensitivity
  of manual time/frequency domain analysis.
</figcaption>

<p>However, this blog post focuses on the automated detection of anomalies and
   faults using machine learning techniques. It’s important to understand that
   the specific formats in which vibration data is represented are less critical
   for deep-learning models, as these tools will ‘learn’ the optimal latent
   representation of the data during the training phase.</p>

<p><strong>Time and Frequency Domain</strong><br />
   So why would a vibration expert use both the time and frequency views?
   Although they represent the same underlying information, each domain has its
   advantages when it comes to detecting specific signal patterns.</p>

<p>For instance, one-time or repetitive transient events in the signal (e.g. a
   mechanical impulse) are easily identified in the time domain, where their
   energy is concentrated in a short interval. However, in the frequency domain,
   the same short event merely appear as a slight wideband bump above the noise
   floor, making them difficult to detect.</p>

<p><img src="/tutorials/assets/images/vibration-pulse-timedomain.png" alt="Impulse response from a bearing defect in time and frequency domains" width="90%" style="margin-left: 1em;" /></p>
<figcaption>
     Figure 14: Example of a short mechanical impulse. Impulse responses are
     easily detectable in the time domain but spread across a broad frequency
     range, particularly in variable-speed machines or for non-repetitive
     events.
   </figcaption>

<p>Early-stage bearing faults (stage 1/2) are most effectively detected with
   piezo sensors at ultrasonic frequencies, where the noise floor is lower and
   thus more favorable to detect unusual patterns in the spectrum.</p>

<p>However for repetitive impulses, energy concentrates around key fault
   frequencies(*), such as BPFI and BPFO (stage 2/3). These which are well
   within the capabilities of modern MEMS sensors. Nevertheless, capturing
   sufficient impulses to rise above the noise floor is essential. Extended
   measurements, however, may still pose challenges for wireless sensors due
   to their data (transfer) and battery constraints.<br />
   (*) More info here:
   <a class="external" href="https://www.reliabilityconnect.com/bearing-problems-fault-frequency-and-artificial-intelligence-based-methods/" target="_blank">[reliabilityconnect.com]
   </a>.</p>

<blockquote>
  <p>Sometimes you need a cost-effective solution for a real-world application
outside the lab. MEMS sensors can offer the middle ground between the
ultimate monitoring equipment and nothing. The amount of data that
continuous monitoring offers often makes the choice for MEMS more suitable
than periodic manual inspections.</p>
</blockquote>

<p><img src="/tutorials/assets/images/vibration-pulse-repetitive.png" alt="Repetitive bearing fault defect in time and frequency domains" width="90%" style="margin-left: 1em;" /></p>
<figcaption>
     Figure 15: Example of a repetitive impact fault. This one is easily
     detected above the noise in the frequency domain as the energy from
     multiple impacts concentrates around the repetition frequency.
   </figcaption>

<p>The above consideration is important for understanding why we use the
   Short-Time Fourier Transform (STFT) when feeding data into the machine
   learning algorithm. The STFT allows us to represent the sensor signal in
   both the time- and frequency-domain simultaneously. By doing so, we capture
   all relevant information (for the sake of simplicity, we exclude phase
   information here) and ensure that the signal power of various fault patterns,
   whether time-based or frequency-based, remains concentrated and is more
   easily detected.</p>

<p><img src="/tutorials/assets/images/vibration-pulse-stft.jpg" alt="STFT heatmap representation of a repetitive impact fault" width="90%" style="margin-left: 1em;" /></p>
<figcaption>
     Figure 16: The STFT provides simultaneous time and frequency resolution.
     This enables machine learning algorithms to detect faults that manifest in
     either domain. The trade-off between time and frequency resolution is a
     fundamental limitation of the STFT
     <a class="external" href="https://sigproc.mit.edu/_static/fall20/lectures/lec09a_slides.pdf" target="_blank">[mit.edu]
     </a>.
   </figcaption>

<p>While it is very possible for a machine learning algorithm to perform domain
   transforms internally, this approach would require a significant portion of
   the model structure (specifically, the convolutional layers) to handle these
   transforms. This would complicate the training phase as it would also take
   considerable training time to tune the ML model parameters to ‘invent’ these
   transforms.</p>

<p><img src="/tutorials/assets/images/vibration-autoencoder-latent.png" alt="Repetitive bearing fault defect in time and frequency domains" width="95%" style="margin-left: 0em;" /></p>
<figcaption>
     Figure 17: STFT data is stacked into a third dimension, then split into
     training, validation, and test sets. Each set is further divided into
     mini-batches to train the autoencoder model. When an unseen vibration
     pattern occurs, the latent space fails to represent it accurately, leading
     to a loss value (i.e. anomaly) proportional to the deviation from the
     machine's normal operating point.
     Image based on
     <a class="external" href="https://en.wikipedia.org/wiki/Autoencoder" target="_blank">[wikipedia.org]
     </a>.
   </figcaption>

<p>By using the STFT as a fixed preprocessing step, we effectively offload this
   task and provide the ML algorithm with a rich feature input that combines
   the strengths of both domains. In this sense, the STFT acts as a pre-trained,
   fixed component of the machine learning model itself, simplifying the
   detection process and reducing the training time for each sensor node.</p>

<hr />
<h4 id="challenges-with-manual-analysis-and-traditional-methods">Challenges with Manual Analysis and Traditional Methods</h4>

<p>Linking specific fault patterns to their root cause typically requires expert
   knowledge. Diagnosing issues like bearing faults or other machine-specific
   anomalies demands experience and regular inspections.</p>

<p>However, these manual methods depend on understanding of the machine’s
   internal dynamics and require the measurements to be done in a constant
   operating point (i.e. speed, load, …) to accurately track fault progression
   over time.</p>

<div style="padding: 0 2em 0.5em 1em">
   <iframe width="560" height="315" src="https://www.youtube.com/embed/67Et4vbKhOM?si=kcDpT6cfHer5wFOe" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
   </iframe>
   </div>
<figcaption>
     Figure 18: Traditional vibration analysis using conventional methods
     requires expert knowledge and is typically not performed on non-critical
     assets due to cost restrictions.
     <br /><i>Credits: Mobius Institute
     <a class="external" href="https://www.mobiusinstitute.com/learn" target="_blank">[mobiusinstitute.com]
     </a></i>.
   </figcaption>

<p>Relying solely on vibration specialists is costly, and the extended intervals
   between inspections can result in missed random faults. Oftentimes, the plant
   operator just wants to be alerted in time about an upcoming problem,
   then follows the fault progress over the next days more closely and will
   replace the faulty component without the need for a detailed report about
   the fault.</p>

<p>For online monitoring, the sheer volume of data –hundreds of plots
   generated daily– makes manual analysis impractical. Automated analysis
   tools are essential here.</p>

<p><img src="/tutorials/assets/images/vibration-thresholds.png" alt="Repetitive bearing fault defect in time and frequency domains" width="95%" style="margin-left: 0em;" /></p>
<figcaption>
     Figure 19: Automated alarm systems often mirror the approach of a
     vibration expert in software, requiring order tracking and manual
     threshold tuning. False alarms may lead operators to ignore alerts
     altogether, including the valid warnings.
     <br /><i>Image: AMC VIBRO
     <a class="external" href="https://amcvibro.com/publications/10-alarm-thresholds/" target="_blank">[amcvibro.com]
     </a></i>.
   </figcaption>

<p>Traditional automated methods, such as frequency binning and manually
   setting thresholds for each bin, have widely proven their value but come
   with inherent limitations.</p>

<ul>
  <li>
    <p><strong>Dependency on Expertise:</strong> Setting accurate thresholds requires good
understanding of the machine’s internals: what operating conditions to
expect (speed, load, etc.) and their associated fault frequencies.</p>
  </li>
  <li>
    <p><strong>Operating point variability:</strong> Threshold-based frequency band or
enveloping alarms are most effective when a machine operates under stable
speeds and loads. In environments with varying conditions, thresholds often
need to be relaxed to avoid false positives, which significantly reduces
the sensitivity of the monitoring system.</p>
  </li>
</ul>

<hr />
<h4 id="enter-the-power-of-machine-learning">Enter the Power of Machine Learning</h4>

<p>Machine learning (ML) techniques offer a more flexible solution to track
   the health of a machine. The models used in ML can represent the machine’s
   time and frequency vibration data using latent (internal) variables, which
   provide an abstract view of the machine’s internal state.</p>

<blockquote>
  <p><strong>Latent Variables:</strong><br />
 In an autoencoder, for example, the ML model is trained to compress the
 vibration data (the STFT representation in our case) into a compact set
 of latent variables, essentially creating what some marketing materials
 might call a “digital twin.”</p>
</blockquote>

<p><img src="/tutorials/assets/images/vibration-vae.png" alt="autoencoder banner" width="90%" style="margin-left: 1em;" /></p>

<p>This discussion will focus on unsupervised learning and <strong>autoencoders</strong> in
   particular, as they can be applied to a broad range of topics, without the
   need for costly manual training.</p>
<blockquote>
  <p>An autoencoder is a type of neural network that learns to compress input
data into a lower-dimensional representation (the encoder) and then
reconstructs it back to the original form (the decoder), capturing only
the essential features in the process.</p>
</blockquote>

<div style="max-width: 20em;">
   <iframe width="560" height="315" src="https://www.youtube.com/embed/JoR5HCs0n0s" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
   </iframe>
   </div>
<figcaption>
     Figure 20: Introduction to Autoencoders.
     <a class="external" href="https://www.youtube.com/sentdex" target="_blank">[youtube.com/Sentdex]
     </a>
   </figcaption>

<p>After the training phase, these <strong>latent variables capture the subtle
   interactions</strong> between speed, load, temperature, and the time and frequency
   domain components of the input signal. Think of this as a more sophisticated
   version of the relationship between machine load and temperature, but in
   multiple dimensions, with more variables and with greater complexity.</p>

<blockquote>
  <p>“Oftentimes, the neural network will discover complex features which are
very useful for predicting the output but may be difficult for a human
to understand or interpret.”<br />
<small>Andrew Ng. CS229 Lecture Notes: Deep Learning, Chapter II. Stanford
University, June 2023.
<br /> Retrieved from
 <a class="external" href="https://cs229.stanford.edu/main_notes.pdf" target="_blank">[stanford.edu]
 </a>
</small></p>
</blockquote>

<p>While the latent variables themselves won’t give us direct insight in the
   machine’s health status, they do provide the foundation to <strong>estimate how
   far the the machine’s current behaviour deviates from its normal operating
   point</strong>. The normal state is defined by a cluster of complex patterns
   captured from the thousands of measurements during the training phase.</p>

<p><img src="/tutorials/assets/images/vibration-t-sne.svg" alt="t-SNE visualization of the latent space of machine operating point" width="100%" style="margin-left: 0em;" /></p>
<figcaption>
     Figure 21: t-SNE visualization of the L-dimensional latent space reveals
     clusters corresponding to different machine operating points. t-SNE is a
     nonlinear transformation that reduces high-dimensional data to 2D or 3D
     for visualization. It keeps similar data points close together in the
     lower-dimensional space that the human brain can interpret.
     <br /><i>More info:
     <a class="external" href="https://www.youtube.com/watch?v=wvsE8jm1GzE" target="_blank">[youtube.com/GoogleDevelopers]
     </a></i>
   </figcaption>

<p>For example, if a harmonic component appears (or disappears for that matter)
   in the STFT that wasn’t present during the training (e.g. a bearing fault),
   or if a specific unexpected combination of harmonics occurs, the latent
   variables won’t be optimized to accurately represent this newfound state.
   As a result, <strong>the decoded output of the autoencoder will start to diverge
   from the input</strong>.</p>

<p><img src="/tutorials/assets/images/vibraton-encode-decode-loss.svg" alt="t-SNE visualization of the latent space of machine operating point" width="100%" style="margin-left: 0em;" /></p>
<figcaption>
     Figure 22: Autoencoder-based anomaly detection using STFT spectrograms.
     The input is compressed into a latent space and decoded again; anomalies
     introduce reconstruction errors, leading to divergence and increased values
     in the loss history plot.
   </figcaption>

<p>This discrepancy between the input STFT and the model’s output STFT is
   measured by a loss function, for example the LogCosh (log of the cosh of
   the prediction error), which <strong>transforms the <em>Δ(out-in)</em> into a
   single numerical value: the loss value</strong> or so-called “anomaly level”.<br />
   The loss value indicates how good the model can represent the current
   measurement and thus indirectly how far the machine is operating from its
   pre-trained cluster of behavioural states.</p>

<p>The next part will return to our real-world example of the vibratory screen.
   We will examine the raw data to better understand the signal itself, feed it
   into the autoencoder and relate the loss value to the events that we can see
   in the raw data. By the end, we’ll have a clearer understanding of what
   machine learning can offer beyond the “black magic box” that it may appear
   to many people.</p>

<hr />

<p><a href="/tutorials/blog/anomaly-detection-vibration-part3">Part 3: Real-world Vibratory Screen Data</a></p>]]></content><author><name>{&quot;avatar&quot;=&gt;&quot;/assets/images/iqunet_logo_bgwhite.svg&quot;, &quot;links&quot;=&gt;[{&quot;label&quot;=&gt;&quot;iQunet.com&quot;, &quot;icon&quot;=&gt;&quot;fas fa-fw fa-house&quot;, &quot;url&quot;=&gt;&quot;https://iqunet.com&quot;}, {&quot;label&quot;=&gt;&quot;LinkedIn&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-linkedin&quot;, &quot;url&quot;=&gt;&quot;https://linkedin.com/company/iqunet/&quot;}, {&quot;label&quot;=&gt;&quot;YouTube&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-youtube&quot;, &quot;url&quot;=&gt;&quot;https://www.youtube.com/channel/UCOPGTm7iW8Xh6ZJP8UBq_nQ&quot;}, {&quot;label&quot;=&gt;&quot;GitHub&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-github&quot;, &quot;url&quot;=&gt;&quot;https://iqunet.github.io/tutorials&quot;}]}</name></author><category term="blog" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Monitoring Power Quality in Industrial Compressors</title><link href="/tutorials/blog/power-quality/" rel="alternate" type="text/html" title="Monitoring Power Quality in Industrial Compressors" /><published>2024-07-12T00:00:00-05:00</published><updated>2024-07-12T00:00:00-05:00</updated><id>/tutorials/blog/power-quality</id><content type="html" xml:base="/tutorials/blog/power-quality/"><![CDATA[<p><img src="/tutorials/assets/images/power-compressor.png" alt="Air Compressor Illustration" width="500" /></p>

<h3 id="introduction">Introduction</h3>
<p>This tutorial covers the practical application of power and current monitoring
sensors to track the power quality of industrial compressors. We demonstrate
which parameters are crucial, such as the cosine φ (displacement power factor)
and the impact of harmonic distortion, providing a detailed insight into these
power quality metrics.</p>

<p><img src="/tutorials/assets/images/power-cosphi-distortion.png" alt="Displacement and Distortion" width="95%" /></p>
<figcaption>figure 1: Displacement (cos &phi;) and Harmonic Distortion.</figcaption>

<p>The ultimate goal is to predict potential failures, such as overheating, and
offer a gateway to the optimization of industrial equipment.</p>

<hr />

<h3 id="technical-background-and-problem">Technical Background and Problem</h3>
<p>Industrial compressors, especially high-power models like the 3-phase 200kW
compressor used in this case study, can cause power quality issues such as
harmonic distortion.</p>

<p>In the upstream transformer cabin, the presence of higher-order frequencies
increases core losses due to eddy currents, resulting in elevated transformer
temperatures. Special K-factor transformers are used to withstand these heating
problems, but the heat losses persist.</p>

<p><img src="/tutorials/assets/images/power-eddycurrents.jpg" alt="FLIR thermal image of eddy currents" width="320" /></p>
<figcaption>figure 2: Eddy currents cause energy losses, such as
  <a class="external" href="https://cr4.globalspec.com/thread/119132/CT-Heating-Problem" target="_blank">here</a> resulting in thermal tripping of a generator.
</figcaption>

<p>Additionally, other equipment connected to the same power grid, such as small
electronic equipment power supplies or capacitor banks, may experience a higher
failure rate due to the stresses induced by the unexpected harmonic currents
oscillating between the 200kW compressor and the passive components in their
power supplies.</p>

<hr />

<h3 id="sensor-deployment-and-capabilities">Sensor Deployment and Capabilities</h3>
<p>One of our clients asked to install a power quality monitoring system at the
entry point of one of their compressor rooms. The goal of this monitoring
system is to gain insight in both the cumulative energy consumption and also
the possible infrastructure improvements learned from the captured sensor data.</p>

<p>For this, two sensors were deployed on the compressor room electrical supply,
each with their specific focus:</p>

<p><strong>iQunet GridMate AG1 Power Quality Monitor:</strong> This LoRaWAN-enabled sensor
measures aggregate data such as average grid voltage, RMS and peak current,
cosine φ, true power factor (TPF) and distortion power (THD) on all three
phases on a 10 minute base interval. This provides us the long-term data
essential for the total energy usage as well as the amount of displacement
power and the harmonic contents.</p>

<p><img src="/tutorials/assets/images/power-gridmate.jpg" alt="AG1 LoRaWAN Power Monitor" /></p>
<figcaption>figure 3: AG1 LoRaWAN Power Monitor.</figcaption>

<p><strong>Wireless Current Waveform Sensor:</strong> Positioned on one of the phases, this
sensor captures high-speed snapshots (4kS/s) of the current waveform and its
spectrum every 10 minutes. It delivers detailed insights into the time-domain
and frequency spectrum and helps to identify the various sources of distortion
and intermittent spike events (such as the upstart of the compressor).</p>

<p><img src="/tutorials/assets/images/power-bridge.jpg" alt="iQunet ADMOD-CURR wireless current clamp" /></p>
<figcaption>figure 4: iQunet wireless current clamp [model ADMOD-CURR].</figcaption>

<p>The combination of these sensors allows for not only real-time analytics but
also provides the historical data necessary for the early detection of potential
faults. In the next chapter, we will delve into this aspect further.</p>

<hr />

<h3 id="initial-findings">Initial Findings</h3>
<p>Within the first few hours, initial data from the AG1 monitor revealed a
considerable level of distortion (approx. D=3x20kVArd at 250 Hz) compared to
170 kW of active power at the 50 Hz fundamental. Although the cosine φ
seemed to be well-corrected at around PF=0.98, the distortion power was the
main factor for reducing the true power factor to around TPF&lt;0.9.</p>

<video width="500px" controls="" loop="" autoplay="" muted="">
  <source src="/tutorials/assets/videos/power-phasor.mp4" type="video/mp4" />
  Your browser does not support the video tag.
</video>
<figcaption>figure 5: Power phasor as shown in the dashboard of the iQunet edge
  server.</figcaption>

<h4 id="waveform-analysis-and-root-cause">Waveform Analysis and Root Cause</h4>
<p>The current waveform sensor (ADMOD-CURR) also identified high harmonic distortion
as seen in the system’s spectral footprint, with significant spectral components
at the 5th (250 Hz) and 7th (350 Hz) harmonics of the fundamental (50 Hz).</p>

<p><img src="/tutorials/assets/images/power-dashboard-spectrum.png" alt="Spectrum plot of the compressor current draw." width="500px" /></p>
<figcaption>figure 6: Spectrum plot of the compressor current draw, as shown
  in the iQunet edge computer dashboard.</figcaption>

<p>Additionally, the time-domain waveform revealed the characteristic ripple caused
by a 6-pulse 3-phase rectifier at the DC-bus input stage of the compressor VFD.</p>

<p><img src="/tutorials/assets/images/power-dashboard-time.png" alt="Waveform snapshot of the compressor current draw." width="500px" /></p>
<figcaption>figure 6: Time-waveform of the compressor current, as shown
  in the iQunet edge computer dashboard.</figcaption>

<h3 id="in-depth-technical-audit">In-depth Technical Audit</h3>
<p>The 5th harmonic was notably significant, making up about 30% of the main
component current in the spectrum plot. From the ratios of the harmonics, it
can be determined that a damping choke is used to “just” comply with the IEEE-519
standard when operating at the nominal power of the compressor.</p>

<p>For more details on this see the “<em>ABB Technical Guide to harmonics with AC drives</em>”
<a class="external" href="https://library.e.abb.com/public/bc35ffb4386c4c039e3a8ec20cef89c5/Technical_guide_No_6_3AFE64292714_RevF_EN.pdf" target="_blank">link
</a>.
<!-- https://vfds.com/what-pulse-vfd-should-you-be-using --></p>

<p><img src="/tutorials/assets/images/power-abb-6pulse-rect.png" alt="Excerpt from the ABB Technical Guide to harmonics." /></p>
<figcaption>figure 7: Excerpt from "ABB Technical Guide to harmonics with AC drives".</figcaption>

<p>At power levels deviating from the nominal operating point, however, it is
observed that the tuning mismatch of the damping choke results in an
increasingly worse THD performance characteristic, leading to non-compliance
with even the regulatory requirements.</p>

<p>More information on the problems of the suppression of harmonics with passive
components can be found 
<a class="external" href="https://powerquality.blog/2022/02/14/voltage-notching-and-distribution-systems-large-induction-motor-drive/" target="_blank">here [powerquality.blog]
</a>.</p>

<p><img src="/tutorials/assets/images/power-thd-plot.png" alt="Cosine &phi; and True Power Factor history." /></p>
<figcaption>Figure 8: History of Cosine &phi; and True Power Factor. Although
  Cosine &phi; regulation is effective, harmonic distortion (THD) increases as
  compressor power decreases. The very high THD levels (TPF&lt;0.8) are believed
  to be caused by 11th harmonic oscillations in the power grid caused by other
  on-site capacitor banks (further investigation needed).
</figcaption>

<hr />

<h3 id="results-and-benefits">Results and Benefits</h3>

<h4 id="insights">Insights</h4>
<p>The two sensors did provide immediate, detailed insights into power consumption
patterns, enabling a deeper understanding of the root causes of heat losses.
The high distortion power is one of the primary issues that must be addressed.</p>

<p>While phase compensation or harmonics suppression with capacitor banks may
offer some (marginal) improvements, there is also the very real increased risk
of damage caused by unexpected resonances between multiple on-site systems.</p>

<p>The customer has now all the necessary information to calculate whether the
cost of a more advanced VFD (e.g. with hybrid harmonic active filter) is
justified to improve to the current situation.
The decision process will not only involve the heat losses in the upstream
transformer cabin, but also the impact of HF harmonics on the lifespan of
nearby electrical and mechanical components, such as parasitic bearing currents
in rotating equipment connected to the same grid.</p>

<p>See “<em>ABB Technical guide No. 5 - Bearing currents in modern AC drive systems</em>”
<a class="external" href="https://library.e.abb.com/public/8c253c2417ed0238c125788f003cca8e/ABB_Technical_guide_No5_RevC.pdf" target="_blank">link
</a>.</p>

<p><img src="/tutorials/assets/images/power-ABB-bearing-current.jpg" alt="Bearing damage due to parasitic currents." width="400px" /></p>
<figcaption>Figure 9: Bearing damage due to parasitic currents [credits: ABB].
</figcaption>

<h4 id="predictive-maintenance">Predictive Maintenance</h4>
<p>By analyzing the current spectrum in a regular inverval, the sensors also enable
the early detection of changes in the electronic or mechanical behavior of the
compressor. This proactive approach can significantly reduce unplanned downtime.</p>

<p><img src="/tutorials/assets/images/power-anomaly.png" alt="Example anomaly detection using Machine Learning." /></p>
<figcaption>Figure 10: Example of Anomaly Detection using Machine Learning.
The step indicates a sudden change in behaviour of the machine, which needs
attention but, because the deviation is stable, does not require immediate
action.
</figcaption>

<blockquote>
  <p><strong>Machine Learning Applications</strong></p>

  <p>iQunet offers an optional service to automate anomaly detection.
Small variations in the machine’s operating state cause related changes in
the spectral footprint of electical current or mechanical vibrations. While
these changes are difficult to detect with the naked eye, a custom-trained
machine learning model can provide a reliable early-warning system for
critical assets, without the need for expert personnel to analyze the sensor
data.</p>
</blockquote>

<hr />

<h3 id="conclusion">Conclusion</h3>
<p>This case study has demonstrated the capabilities of modern sensor technology
in tackling power quality issues in industrial settings.</p>

<p>By providing detailed measurements, the combination of the appropriate voltage
and current sensors enables precise registration of energy usage, along with
the identification of the root causes of energy losses due to harmonic distortion
currents.
For the more experienced user, it offers valuable insights into the installed
equipment, down to the ability to determine the VFD characteristics of attached
machinery through black-box analysis.</p>

<p>Finally, armed with this knowledge, the customer can take informed steps to
implement future operational improvements and monitor emerging anomalies as
a foundation for predictive maintenance.</p>

<p>For more detailed technical insights and support, explore our <a href="https://iqunet.com/resources/">documentation</a> and <a href="https://iqunet.com/resources/case-studies/case-study-1-international-airport/">case studies</a>, or contact our <a href="https://iqunet.com/contact/">support team</a>.</p>]]></content><author><name>{&quot;avatar&quot;=&gt;&quot;/assets/images/iqunet_logo_bgwhite.svg&quot;, &quot;links&quot;=&gt;[{&quot;label&quot;=&gt;&quot;iQunet.com&quot;, &quot;icon&quot;=&gt;&quot;fas fa-fw fa-house&quot;, &quot;url&quot;=&gt;&quot;https://iqunet.com&quot;}, {&quot;label&quot;=&gt;&quot;LinkedIn&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-linkedin&quot;, &quot;url&quot;=&gt;&quot;https://linkedin.com/company/iqunet/&quot;}, {&quot;label&quot;=&gt;&quot;YouTube&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-youtube&quot;, &quot;url&quot;=&gt;&quot;https://www.youtube.com/channel/UCOPGTm7iW8Xh6ZJP8UBq_nQ&quot;}, {&quot;label&quot;=&gt;&quot;GitHub&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-github&quot;, &quot;url&quot;=&gt;&quot;https://iqunet.github.io/tutorials&quot;}]}</name></author><category term="blog" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Modbus to MQTT</title><link href="/tutorials/blog/modbus-to-mqtt/" rel="alternate" type="text/html" title="Modbus to MQTT" /><published>2024-05-24T05:06:19-05:00</published><updated>2024-05-24T05:06:19-05:00</updated><id>/tutorials/blog/modbus-to-mqtt</id><content type="html" xml:base="/tutorials/blog/modbus-to-mqtt/"><![CDATA[<p><span style="background-color: #ffff0054">
<strong>Note:</strong> This tutorial uses the iQunet Industrial Edge Server
[<a href="https://iqunet.com/products/servers/">link</a>].
<br />A demo gateway endpoint is provided for the purpose of this guide.
</span></p>

<h3 id="mission-publish-modbus-over-mqtt-plot-in-python">Mission: Publish Modbus over MQTT, plot in Python</h3>
<p><img src="/tutorials/assets/images/iqunet-setup-modbus-2.svg" alt="Modbus Example Hardware Setup" style="width: 16em" /></p>

<p>In this tutorial, you will learn how to:</p>
<ul>
  <li>Connect a <strong>Modbus-RTU</strong> motor drive to the iQunet Industrial Edge Server.</li>
  <li>Understand the steps how sensor data is stored in the <strong>local OPC-UA database</strong>.</li>
  <li>Next, publish this sensor data in realtime to an <strong>MQTT broker</strong>.</li>
  <li>Subscribe to the MQTT broker using <strong>Python</strong> for post-processing and visualization.
<br /></li>
</ul>
<hr />

<h3 id="terminology">Terminology</h3>

<blockquote>
  <p><strong>Modbus</strong> is a wired communication protocol for industrial automation
and data exchange between devices like sensors and PLC controllers.
Visit <a href="https://modbus.org">modbus.org</a>.</p>

  <ul>
    <li><strong>Modbus-RTU:</strong> Uses serial wired communication (RS-232/RS-485) for
short-distance, point-to-point, or multi-drop connections.</li>
    <li><strong>Modbus-TCP:</strong> Runs over Ethernet, using TCP/IP for integration with
modern IT systems. A gateway is used to convert between Modbus-RTU and -TCP.</li>
  </ul>
</blockquote>

<p><img src="/tutorials/assets/images/modbus-mqtt-python.svg" alt="LoRaWAN to OPC UA" /></p>

<blockquote>
  <p><strong>MQTT</strong> (Message Queuing Telemetry Transport) is a lightweight, publish-subscribe
network protocol designed for resource-constrained devices and low-bandwidth,
high-latency networks. It is widely used in internet-oriented services,
particularly for IoT applications. In contrast to OPC-UA, the payload format
is not part of the specification. Visit <a href="https://mqtt.org">mqtt.org</a>.</p>
</blockquote>
<hr />

<h3 id="typical-modbus-to-mqtt-information-flow">Typical Modbus-to-MQTT Information Flow</h3>

<p>In a typical Modbus/MQTT monitoring setup, an industrial device,
<span>— </span>such as a <strong>motor drive</strong><span> —</span>
is connected to a <strong>Modbus-TCP gateway</strong> via an RS-485 serial interface.
The gateway converts between the synchronous Modbus-RTU protocol and the
asynchronous Modbus-TCP Ethernet network protocol. This allows the use of
standard networking equipment. Some devices natively support Modbus-TCP,
which eliminates the need for a gateway.</p>

<p><img src="/tutorials/assets/images/typical-modbus.svg" alt="Typical LoRaWAN setup" /></p>
<figcaption>figure 1: Typical Modbus to MQTT information flow</figcaption>

<p>A <strong>Modbus-TCP master</strong> actively polls connected devices to extract data, which
is subsequently decoded from binary to a user-friendly format, typically
JSON. This JSON data is then published to an MQTT platform, either on-premises
or cloud-based, such as the HiveMQ <strong>MQTT broker</strong>.</p>

<p>An <strong>MQTT subscriber</strong> retrieves the data from the broker and stores it in a database.
This database then serves as a data source for real-time or historical operational
dashboards, providing the user with insight into emerging faults, predictive
maintenance or energy efficiency.</p>

<p class="notice"><em>Configuring the Modbus-TCP master and decoding data demand deep understanding of
each device’s register map, requiring significant expertise and effort with every
new device integration.<br />
An example of such a manual setup procedure can be found here 
<a href="https://www.hivemq.com/blog/modbus-mqtt-integration-c-sharp-gateway-hivemq-mqtt-client/">hivemq.com <i style="margin: 0.2em; font-size: 0.7em" class="fa-solid fa-arrow-up-right-from-square"></i></a>.
<br />
<br />
The required expertise and effort may lead to a higher TCO and project delays
than initially projected, making a ready-to-use solution an attractive and efficient
alternative.</em></p>

<hr />

<h3 id="a-single-board-modbus-to-mqtt-setup">A Single-Board Modbus-to-MQTT Setup</h3>

<p>The Modbus-TCP gateway, Modbus master and MQTT publisher can all be integrated in
a single board computer (SBC), such as is the case for the iQunet Edge Server
[<a href="https://iqunet.com/products/servers/">link</a>].
Data collected via Modbus is first decoded and stored in the on-board <strong>OPC-UA historian
database</strong>.
<br />
This data can be routed (LAN/VPN) and accessed with the embedded dashboard
webserver or via various protocols, including OPC-UA, GraphQL or CSV. In a
second step, realtime updates in the OPC-UA server can be linked to the
onboard MQTT publisher for integration with third-party IoT platforms.
<br /></p>

<p><img src="/tutorials/assets/images/iqunet-modbus.svg" alt="iQunet LoRaWAN setup" /></p>
<figcaption>figure 2: iQunet single-server Modbus/MQTT gateway setup.</figcaption>

<p>In this tutorial, the <strong><span style="background-color:#ff9494">red route</span></strong>
indicated in figure 2 will be used. The motor drive is connected via an FTDI-232R
galvanically isolated interface to the iQunet Server, which polls the drive at a
configurable interval. The payload is then decoded, unpacked and written to the
<strong>built-in database</strong>.</p>

<h3 id="publishing-to-mqtt">Publishing to MQTT</h3>
<p>When a new measurement is written into the database, the OPC-UA server triggers
a callback that activates the MQTT publisher. The new measurement is first
converted into <strong>JSON format</strong> and published to the MQTT broker.<br />
The <strong>topic of the MQTT message</strong> is derived from the path of the corresponding
data point in the OPC-UA tree (figure 3).</p>

<p><img src="/tutorials/assets/images/iqunet-opcua-mqtt.svg" alt="iQunet OPC-UA" /></p>
<figcaption>figure 3: iQunet embedded OPC-UA server API</figcaption>

<p>In this tutorial, a Python program will then subscribe to the specified topic
on the MQTT broker and display the incoming data on a real-time updated graph.</p>
<hr />

<h3 id="motor-drive--modbus-hardware-setup">Motor Drive + Modbus Hardware Setup</h3>

<p>Figure 4 shows the minimal setup required to publish real-time motor drive data
via MQTT. This configuration includes the <strong>inverter drive</strong> itself, an (optional)
Ethernet <strong>network switch</strong>, the <strong>iQunet server</strong>, and a mobile <strong>access point</strong>,
which serves as a temporary placeholder for, for example, a company VLAN. The
Modbus-RTU to TCP gateway is omitted because the drive depicted in Figure 4 is
equipped with a Modbus-TCP communication module.</p>

<p>With this setup, MQTT data can be transmitted to either a private or a public
internet-based MQTT broker.</p>

<p><img src="/tutorials/assets/images/iqunet-setup-modbus.svg" alt="Modbus Example Hardware Setup" /></p>
<figcaption>figure 4: The setup with motor drive, iQunet server and access point.
</figcaption>

<p>For the remainder of this tutorial, the Invertek Optidrive E3 will be used.
The Optidrive inverter supports both Modbus-RTU and Modbus-TCP via an additional
module. However, because the Profinet IO module occupies the sole available slot
for PLC drive control, the on-board Modbus-RTU is used. A separate RS-485 to USB
converter is used for <strong>monitoring</strong> the drive parameters in <strong>read-only mode</strong>.
<br /></p>

<p><img src="/tutorials/assets/images/modbus-monitor-loop.svg" alt="Profinet Control and Modbus Monitor loop" /></p>
<figcaption>figure 5: Optidrive E3 - PLC control via Profinet and monitoring via Modbus-RTU.
</figcaption>
<hr />

<h3 id="scanning-for-modbus-devices">Scanning for Modbus Devices</h3>
<p>After the hardware is connected and powered up as shown in figure 4, the
Optidrive E3 must be added to the list of monitored devices in the iQunet
server software.</p>

<p>The first step involves activating both the Modbus-TCP and the Modbus-RTU modules
in the dashboard of the iQunet server. For this, click the Config button
<i style="margin: 0.2em; font-size: 0.7em" class="fa-solid fa-wrench"></i> in
the menu bar, as shown in Figure 6.</p>

<p><img src="/tutorials/assets/images/iqunet-modbus-enable.svg" alt="iQunet Enable Modbus in Dashboard" /></p>
<figcaption>figure 6: Enable the Modbus-TCP master and the Modbus-RTU gateway.</figcaption>

<ul>
  <li>The <strong>Modbus-TCP</strong> software module provides <strong>Modbus master</strong> functionality,
which includes probing the connected devices at regular intervals and forwarding
data to the OPC-UA historian database.</li>
  <li>The <strong>Modbus-RTU</strong> module enables the drivers for the FTDI FT232R USB-to-serial
interface and serves as a <strong>gateway</strong> for the Modbus master to communicate with
RTU devices.</li>
</ul>

<p>After both Modbus modules are enabled, the Home menu <i class="fa-solid fa-home"></i>
will display a new Modbus Master and Gateway node in the OPC-UA device list.</p>

<p>The Modbus Master allows <strong>scanning a single IP or subnet</strong> for known devices
(figure 7):</p>

<p><img src="/tutorials/assets/images/iqunet-modbus-tcp-scan.svg" alt="iQunet Modbus TCP Scanner" /></p>
<figcaption>figure 7: Scanning a LAN subnet for Modbus-TCP devices.</figcaption>

<p>The scanner is also capable of scanning not only for <strong>Modbus slave devices</strong> on
the <strong>local network</strong> (Ethernet or WiFi) but also for <strong>remote devices</strong> via any
configured <strong>Wireguard VPN</strong> endpoint on the iQunet server.</p>

<p>The <strong>Modbus-RTU gateway</strong> operates similarly, scanning all <strong>slave Unit IDs</strong>
within the configured range, as illustrated in Figure 8. Because Modbus-RTU is a
synchronous <strong>serial protocol</strong>, parallel scanning is not feasible. Therefore,
probing the full range of all slave IDs from 1 to 247 may take a minute or two.</p>

<p><img src="/tutorials/assets/images/iqunet-modbus-rtu-scan.svg" alt="iQunet Modbus RTU Scanner" /></p>
<figcaption>figure 7: Scanning all Unit IDs of a Modbus-RTU network.</figcaption>
<hr />

<h3 id="auto-detection-of-modbus-devices">Auto-Detection of Modbus Devices</h3>
<p>When the iQunet server detects a Modbus slave device on the network, it attempts
to identify the specifics of the slave for auto-configuration purposes. This
process serves two main objectives:</p>
<ul>
  <li><strong>Device Identification</strong>: A unique device MAC address is derived from the
device serial number. This allows for flexible remapping of IP addresses or
Unit (Slave) IDs, with monitoring data <strong>tied to the device serial</strong> rather than
the location in the network or the MAC address of the Modbus network card.</li>
  <li><strong>Device Type Detection</strong>: This is crucial for <strong>automatic payload decoding</strong>.
iQunet provides customized payload decoders upon request. The configuration
for the end-user is reduced to setting some basic parameters such as the
polling interval and the selection of data to be published to MQTT. This
<strong>simplifies the commissioning</strong> of new devices in the field, reducing the
setup time to a matter of minutes.</li>
</ul>

<p>In Figure 8 below, the <strong>Optidrive E3</strong> inverter is detected on the local
<strong>Modbus-RTU gateway</strong> at <strong>Unit ID 1</strong>. The dashboard automatically adapts to
the device specifics and displays the most important configuration highlights
of the device, such as the serial number, hardware model, and current
configuration (e.g., closed-loop <strong>vector control</strong> mode):</p>

<p><img src="/tutorials/assets/images/iqunet-optidrive-eco-status.svg" alt="iQunet Optidrive Eco dashboard" /></p>
<figcaption>figure 8: Auto-detection and configuration of the Modbus payload decoder.</figcaption>

<p>In addition to the static configuration, <strong>real-time drive</strong> and
<strong>historical parameters</strong> are also available in the dashboard. The generic motor
drive section (Figure 9) displays the most common parameters.</p>

<p><img src="/tutorials/assets/images/iqunet-optidrive-eco-monitor.svg" alt="iQunet Generic Motor drive monitor" /></p>
<figcaption>figure 9: Displaying real-time and historical drive parameters.</figcaption>

<p>While the dashboard provides a graphical summary of the drive status, much more
detailed information about drive parameters and historical logs can be accessed
by directly <strong>browsing the OPC-UA node tree</strong> of the internal OPC-UA server. To
do this, click the OPC-UA icon in the left menu:</p>

<p><img src="/tutorials/assets/images/iqunet-optidrive-eco-opcua-dashboard.svg" alt="iQunet OPC-UA browser" /></p>
<figcaption>figure 10: Accessing and exporting drive parameters via the OPC-UA browser.</figcaption>

<p>The built-in OPC-UA browser allows immediate export to <strong>Google Sheets</strong> or a
plain <strong>CSV file</strong>. Additionally, as shown in Figure 10, any variable node of the
OPC-UA tree can be enabled for <strong>publication via MQTT</strong> to an external broker.</p>
<hr />

<h3 id="direct-access-of-modbus-data-via-opc-ua">Direct Access of Modbus Data via OPC-UA</h3>
<p>All <strong>historical Modbus data</strong> is stored in the <strong>OPC-UA database</strong> of the iQunet
server. It can either be browsed via the dashboard of the web interface, or through
<strong>third-party OPC-UA clients</strong> such as UaExpert, a popular OPC-UA client developed
by Unified Automation
[<a href="https://www.unified-automation.com/products/development-tools/uaexpert.html">unified-automation.com</a>].</p>

<p>Figure 11 shows the configuration of UaExpert to connect to the iQunet OPC-UA
server at address 192.168.10.101, port 4840. Both encrypted and non-encrypted
connections are supported.</p>

<p><img src="/tutorials/assets/images/uaexpert-setup.svg" alt="UaExpert Setup" /></p>
<figcaption>figure 11: Unified Automation UaExpert OPC-UA client connection setup.</figcaption>

<p>When the <strong>UaExpert client</strong> is successfully connected to the <strong>iQunet OPC-UA server</strong>,
direct access is provided to all real-time motor drive parameters, metadata and
historical values as stored in the local database.</p>

<p><img src="/tutorials/assets/images/iqunet-optidrive-eco-opcua-uaexpert.svg" alt="UaExpert OPC-UA browser" /></p>
<figcaption>figure 12: Accessing historical data with the UaExpert OPC-UA client.</figcaption>
<hr />

<div class="notice">
  <h3 id="opc-ua-vs-mqtt-payload-format-and-data-types">OPC-UA vs MQTT: Payload Format and Data Types</h3>
  <p><strong>MQTT</strong> is a widely used protocol for large-scale, <strong>multi-site IoT deployments</strong>.
However, it does not define a specific data format. <strong>JSON</strong> is commonly used
as the payload encoding, but it lacks data type definitions for the payload,
and thus needs careful manual coordination between data publishers and
subscribers to ensure mutual compatibility.</p>

  <p>On the other hand, <strong>OPC-UA</strong> is highly suitable for low latency networks,
real-time data exchange, and has <strong>well-defined object type formatting</strong>.
It allows OPC-UA clients to autonomously resolve data type definitions without
user intervention. However, the protocol is currently not widely used in
internet-oriented big data platforms.</p>

  <p>For maximum flexibility, the iQunet server supports both protocols and employs
the following strategy to link the OPC-UA core system to the MQTT subsystem:</p>

  <ul>
    <li>The OPC-UA node <strong>tree path is used as the topic</strong> for publishing data via MQTT.
A user-definable “Root/” can be prepended to the path (default: server name).</li>
    <li>The <strong>JSON payload</strong> consists of a dictionary dump, which includes the
<strong>numerical, string, or array data</strong>, and the <strong>source-</strong> and <strong>serverTimestamp</strong>
in ISO-8601 format.</li>
  </ul>
</div>

<h3 id="enabling-the-mqtt-subsystem-for-the-iqunet-server">Enabling the MQTT Subsystem for the iQunet Server</h3>
<p>Enabling the MQTT subsystem for the iQunet server is straightforward.</p>

<ul>
  <li>Click on the <strong>MQTT icon</strong> in the left-hand menu.</li>
  <li>Fill in the <strong>MQTT broker host details</strong> and credentials.<br />
Optionally, set a custom <strong>Client ID</strong> (also serves as the root of the topics).</li>
  <li>If supported by the broker, select the <strong>TLS</strong> encryption option.<br />
Finally, toggle the button “MQTT OFF” to <strong>“MQTT ON”</strong>.</li>
  <li>If the <span style="background-color: #abffab"><strong>ONLINE</strong></span> icon is
highlighted, the setup is complete and operational.</li>
</ul>

<p><img src="/tutorials/assets/images/iqunet-mqtt-configuration.svg" alt="iQunet Server MQTT Configuration Menu" /></p>
<figcaption>figure 13: MQTT Configuration Menu in the iQunet Dashboard.</figcaption>

<p>The MQTT setup menu also displays a list of all published nodes and their
respective topics. To add a node to this list, browse to the desired node in
the OPC-UA tree and click the <strong>MQTT “publish”</strong> button.</p>

<p><img src="/tutorials/assets/images/iqunet-mqtt-addnode.svg" alt="iQunet Server MQTT Add Published Node" /></p>
<figcaption>figure 14: Publish a new node via MQTT in the iQunet Dashboard.</figcaption>

<h3 id="testing-the-mqtt-setup">Testing the MQTT Setup</h3>
<p>To verify the MQTT setup, a <strong>web-based MQTT client</strong> will be connected to the
broker to subscribe to the published data. Since browsers do not support raw
TCP sockets, the WebSocket port of the broker will be used.</p>

<p>First, open the <strong>HiveMQ MQTT Client</strong>
[<a href="https://www.hivemq.com/demos/websocket-client/">hivemq.com</a>], and setup the
broker host and TLS WebSocket port as below. Then click connect.</p>
<ul>
  <li><strong>host</strong>: broker.hivemq.com</li>
  <li><strong>port</strong>: 8884 (wss://)</li>
</ul>

<p><img src="/tutorials/assets/images/hivemq-mqtt-client.svg" alt="Connecting the HiveMQ MQTT demo client" /></p>
<figcaption>figure 15: Connect the HiveMQ MQTT client to wss://broker.hivemq.com.
</figcaption>

<p>Next, click <strong>“Add New Topic Subscription”</strong> and choose the topic to
subscribe to. Use a multilevel wildcard (#) to subscribe to all topics at once.
More information here [<a href="https://www.hivemq.com/blog/mqtt-essentials-part-5-mqtt-topics-best-practices/">hivemq.com</a>]</p>

<p>For example, if the topic published to by the iQunet Server is<br />
<code class="language-plaintext highlighter-rouge">SERN-dca632xxxxxx/Objects/b1:dd:1f:e9/inverterTemperature</code>,
then subscribe to<br />
<code class="language-plaintext highlighter-rouge">SERN-dca632xxxxxx/#</code> to capture all messages from this server.</p>

<p><img src="/tutorials/assets/images/hivemq-mqtt-subscribe.svg" alt="Subscribing the HiveMQ client to a topic" /></p>
<figcaption>Figure 16: Subscribing to a topic and viewing incoming JSON data.</figcaption>

<p>If the configuration is correct, JSON packets will start arriving as soon as
they are published by the iQunet Server!</p>
<hr />

<h3 id="subscribing-to-mqtt-and-plotting-with-python">Subscribing to MQTT and Plotting with Python</h3>
<p>This section provides Python boilerplate code to demonstrate how to subscribe
to the MQTT broker, receive data from the iQunet server, and visualize this
data in real-time.</p>

<video width="100%" controls="" loop="" autoplay="" muted="">
  <source src="/tutorials/assets/videos/test3.mp4" type="video/mp4" />
  Your browser does not support the video tag.
</video>

<p>The <a href="https://pypi.org/project/paho-mqtt/">Paho MQTT client</a> is used for handling
MQTT communication, and <a href="https://pypi.org/project/matplotlib/">Matplotlib</a>
is used for plotting the data.</p>

<ul>
  <li>
    <p><strong>MQTT Client Configuration</strong>: The Paho MQTT client connects to the HiveMQ
 broker at <code class="language-plaintext highlighter-rouge">broker.hivemq.com</code> on TCP/TLS port <code class="language-plaintext highlighter-rouge">8883</code> and subscribes to the
 specified topic where the iQunet server publishes data.</p>
  </li>
  <li>
    <p><strong>Message Handling</strong>: When a message is received, the <code class="language-plaintext highlighter-rouge">on_message</code> callback
 parses the JSON payload and appends the data to an in-memory <code class="language-plaintext highlighter-rouge">cache</code>.
 The <code class="language-plaintext highlighter-rouge">data_event</code> signals to the plotting thread that new data is available.</p>
  </li>
  <li>
    <p><strong>Plotting</strong>: The <code class="language-plaintext highlighter-rouge">update_plot</code> function retrieves data from the cache,
 extracts timestamps and values, and updates the plot. The <code class="language-plaintext highlighter-rouge">FuncAnimation</code>
 class from Matplotlib refreshes the plot every second.</p>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib.animation</span> <span class="kn">import</span> <span class="n">FuncAnimation</span>
<span class="kn">import</span> <span class="nn">paho.mqtt.client</span> <span class="k">as</span> <span class="n">mqtt</span>

<span class="c1"># MQTT setup
</span><span class="n">BROKER</span> <span class="o">=</span> <span class="s">'broker.hivemq.com'</span>
<span class="n">PORT</span> <span class="o">=</span> <span class="mi">8883</span>
<span class="n">TOPIC</span> <span class="o">=</span> <span class="s">'SERN-dca632c03aee/Objects/b1:dd:1f:e9/inverterTemperature'</span>

<span class="c1"># In-memory storage
</span><span class="n">cache</span> <span class="o">=</span> <span class="n">deque</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="mi">1024</span><span class="p">)</span>

<span class="c1"># Event to trigger plot updates
</span><span class="n">data_event</span> <span class="o">=</span> <span class="n">threading</span><span class="p">.</span><span class="n">Event</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">on_connect</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">userdata</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">properties</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'Connected with result code </span><span class="si">{</span><span class="n">rc</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="n">client</span><span class="p">.</span><span class="n">subscribe</span><span class="p">(</span><span class="n">TOPIC</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">on_message</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">userdata</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
    <span class="n">payload</span> <span class="o">=</span> <span class="n">json</span><span class="p">.</span><span class="n">loads</span><span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="n">payload</span><span class="p">)</span>
    <span class="n">cache</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
    <span class="n">data_event</span><span class="p">.</span><span class="nb">set</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">start_mqtt_loop</span><span class="p">():</span>
    <span class="n">client</span> <span class="o">=</span> <span class="n">mqtt</span><span class="p">.</span><span class="n">Client</span><span class="p">(</span><span class="n">mqtt</span><span class="p">.</span><span class="n">CallbackAPIVersion</span><span class="p">.</span><span class="n">VERSION2</span><span class="p">)</span>
    <span class="n">client</span><span class="p">.</span><span class="n">tls_set</span><span class="p">()</span>
    <span class="n">client</span><span class="p">.</span><span class="n">on_connect</span> <span class="o">=</span> <span class="n">on_connect</span>
    <span class="n">client</span><span class="p">.</span><span class="n">on_message</span> <span class="o">=</span> <span class="n">on_message</span>
    <span class="n">client</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">BROKER</span><span class="p">,</span> <span class="n">PORT</span><span class="p">,</span> <span class="n">keepalive</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
    <span class="n">client</span><span class="p">.</span><span class="n">loop_start</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">client</span>

<span class="k">def</span> <span class="nf">update_plot</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">ax</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">data_event</span><span class="p">.</span><span class="n">is_set</span><span class="p">():</span>
        <span class="n">time</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="n">c</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">datetime</span><span class="p">.</span><span class="n">fromisoformat</span><span class="p">(</span><span class="n">pl</span><span class="p">[</span><span class="s">'SourceTimestamp'</span><span class="p">])</span> <span class="k">for</span> <span class="n">pl</span> <span class="ow">in</span> <span class="n">c</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">pl</span><span class="p">[</span><span class="s">'Value'</span><span class="p">]</span> <span class="k">for</span> <span class="n">pl</span> <span class="ow">in</span> <span class="n">c</span><span class="p">]</span>

    <span class="n">ax</span><span class="p">.</span><span class="n">clear</span><span class="p">()</span>
    <span class="n">ax</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'o'</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">70</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="mi">45</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s">'right'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">bottom</span><span class="o">=</span><span class="mf">0.30</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Inverter Temperature'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Timestamp'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'degC'</span><span class="p">)</span>
    <span class="n">data_event</span><span class="p">.</span><span class="n">clear</span><span class="p">()</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">client</span> <span class="o">=</span> <span class="n">start_mqtt_loop</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">update_plot</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">ani</span> <span class="o">=</span> <span class="n">FuncAnimation</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">cache_frame_data</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">client</span><span class="p">.</span><span class="n">disconnect</span><span class="p">()</span>
</code></pre></div></div>

<hr />

<h3 id="conclusion">Conclusion</h3>
<p>In this tutorial, we’ve demonstrated how to integrate a <strong>Modbus-RTU</strong> motor drive
with the <strong>iQunet Industrial Edge Server</strong>, store sensor data in a <strong>local OPC-UA
database</strong>, publish this sensor data to an <strong>MQTT broker</strong>, and finally
<strong>visualize</strong> the data using Python for a <strong>real-time monitoring</strong> setup.</p>

<p>Beyond the basics covered in this guide, iQunet offers extensive capabilities
for more advanced data processing tasks. These include handling complex datasets
like vibration data, implementing machine learning techniques for predictive
maintenance, and enabling custom software adaptations for specific industrial
needs.</p>

<p><span style="background-color: #ffff0054">
For further exploration and support, check out our
<a href="https://iqunet.com/resources/"><strong>documentation</strong></a>, get new ideas from some
<a href="https://iqunet.com/resources/case-studies/case-study-1-international-airport/"><strong>case studies</strong></a>
or reach out to our <a href="https://iqunet.com/contact/"><strong>support team</strong></a>.
Happy data monitoring!
</span></p>]]></content><author><name>{&quot;avatar&quot;=&gt;&quot;/assets/images/iqunet_logo_bgwhite.svg&quot;, &quot;links&quot;=&gt;[{&quot;label&quot;=&gt;&quot;iQunet.com&quot;, &quot;icon&quot;=&gt;&quot;fas fa-fw fa-house&quot;, &quot;url&quot;=&gt;&quot;https://iqunet.com&quot;}, {&quot;label&quot;=&gt;&quot;LinkedIn&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-linkedin&quot;, &quot;url&quot;=&gt;&quot;https://linkedin.com/company/iqunet/&quot;}, {&quot;label&quot;=&gt;&quot;YouTube&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-youtube&quot;, &quot;url&quot;=&gt;&quot;https://www.youtube.com/channel/UCOPGTm7iW8Xh6ZJP8UBq_nQ&quot;}, {&quot;label&quot;=&gt;&quot;GitHub&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-github&quot;, &quot;url&quot;=&gt;&quot;https://iqunet.github.io/tutorials&quot;}]}</name></author><category term="blog" /><summary type="html"><![CDATA[Note: This tutorial uses the iQunet Industrial Edge Server [link]. A demo gateway endpoint is provided for the purpose of this guide.]]></summary></entry><entry><title type="html">Private LoRaWAN to OPC-UA</title><link href="/tutorials/blog/connecting-sensors-opcua/" rel="alternate" type="text/html" title="Private LoRaWAN to OPC-UA" /><published>2024-05-19T15:10:15-05:00</published><updated>2024-05-19T15:10:15-05:00</updated><id>/tutorials/blog/connecting-sensors-opcua</id><content type="html" xml:base="/tutorials/blog/connecting-sensors-opcua/"><![CDATA[<h3 id="mission-lorawan-temperature-data-to-python-graph">Mission: LoRaWAN Temperature Data to Python Graph</h3>

<p><img src="/tutorials/assets/images/lora-opc-python.svg" alt="LoRaWAN to OPC UA" /></p>

<p><span style="background-color: #ffff0054">
<strong>Note:</strong> This tutorial uses the iQunet Industrial Edge Server
[<a href="https://iqunet.com/products/servers/">link <i style="margin: 0.2em; font-size: 0.7em" class="fa-solid fa-arrow-up-right-from-square"></i></a>].
<br />A demo gateway endpoint is provided for the purpose of this guide.
</span></p>

<blockquote>
  <p>LoRaWAN (Long Range Wide Area Network) is a wireless communication protocol
designed for low-power, long-range, and low-data-rate applications. This makes
it ideal for IoT devices. For more detailed information, visit
<a href="https://lora-alliance.org/about-lorawan/">lora-alliance.org</a>.
<br /></p>
</blockquote>

<blockquote>
  <p>OPC-UA (Open Platform Communications Unified Architecture)
is a machine-to-machine communication protocol for industrial automation
developed for secure, realtime data exchange. Visit
<a href="https://opcfoundation.org/about/opc-technologies/opc-ua/">opcfoundation.org</a>.</p>
</blockquote>

<p>You will learn how to:</p>
<ul>
  <li>Connect a <strong>LoRaWAN sensor</strong> to the iQunet Industrial Edge Server.</li>
  <li>Understand how sensor data is stored into the <strong>local OPC-UA database</strong>.</li>
  <li>Test the OPC-UA server connection using <strong>UaExpert</strong>.</li>
  <li>Use <strong>Python</strong> to connect to the OPC-UA server for post-processing and visualization.
<br /></li>
</ul>
<hr />

<h3 id="typical-lorawan-network-infrastructure">Typical LoRaWAN Network Infrastructure</h3>

<p>In a standard LoRaWAN setup, a sensor sends data to a <strong>gateway</strong>, which
then forwards the encrypted data to a <strong>network server</strong> via the internet.
The network server buffers the data and forwards it to an <strong>application server</strong>
via MQTT [<a href="https://mqtt.org/">mqtt.org</a>]. The application server decrypts and unpacks
the binary sensor data and stores the measurement in a database, where it can
be retrieved by, for example, <strong>dashboarding software</strong> for visualization.</p>

<p><img src="/tutorials/assets/images/typical-lora.svg" alt="Typical LoRaWAN setup" /></p>
<figcaption>figure 1: Typical LoRaWAN setup for large networks</figcaption>
<p>This multi-step process can be quite challenging for a simple one-time setup,
particularly when integrating software from different vendors.</p>
<hr />

<h3 id="a-single-board-private-lorawan-setup">A Single-Board Private LoRaWAN Setup</h3>

<p>The LoRaWAN gateway, network/application server and database can all be
integrated in a single device, such as is the case for the iQunet Edge Server
[<a href="https://iqunet.com/products/servers/">link</a>].
The result is a secure standalone LoRaWAN network which requires only a <strong>local
network</strong> (LAN) connection for API data access. Sensor data is immediately written
to the <strong>local database</strong> and can be accessed via various protocols: OPC-UA, GraphQL,
MQTT, CSV or the internal web interface.
<br /></p>

<p><img src="/tutorials/assets/images/iqunet-lora.svg" alt="iQunet LoRaWAN setup" /></p>
<figcaption>figure 2: iQunet single-server LoRaWAN setup for
medium size networks (e.g. 250 devices)</figcaption>
<p>In this tutorial, the <strong><span style="background-color:#ff9494">red route</span></strong>
indicated in figure 2 will be used. The iQunet Server will receive the
LoRaWAN packets via the attached <strong>LoRa concentrator</strong> radio module, <strong>decode
and unpack</strong> the payload and store the data in the <strong>built-in database</strong>.</p>

<h3 id="the-opc-ua-server-interface">The OPC-UA server interface</h3>

<p>After being written to the database, the data is made accessible via the 
<strong>embedded OPC-UA server</strong>.
Measurements related to a single LoRaWAN sensor are organized under the
corresponding DevEUI node of that sensor in the OPC-UA node tree (see figure 3).</p>

<p><img src="/tutorials/assets/images/iqunet-opcua.svg" alt="iQunet OPC-UA" /></p>
<figcaption>figure 3: iQunet embedded OPC-UA server API</figcaption>
<hr />

<h3 id="lorawan-hardware-setup">LoRaWAN Hardware Setup</h3>

<p>Figure 4 shows a modular setup for a <strong>private LoRaWAN network</strong>. It consists
of an <strong>SX1302 LoRa Radio</strong> receiver, an iQunet Edge SBC (database and OPC-UA
server) and an (optional) 4G mobile router. The router is the temporary
placeholder for -for example- a company VLAN.</p>

<p><img src="/tutorials/assets/images/iqunet-setup.svg" alt="iQunet Base Setup" /></p>
<figcaption>figure 4: The setup with SX1302 concentrator module,
OPC-UA server and mobile network</figcaption>

<p>For the purpose of this tutorial, the Dragino LSN50v2-S31 temperature and
humidity LoRaWAN sensor will be used. Both the LSN50 and the iQunet server
understand the OTAA (over-the-air activation) protocol v1.0.4. OTAA allows to
automatically generate and exchange the network and application security keys
between sensor and the target application.
<br /></p>

<p><img src="/tutorials/assets/images/lsn50v2-s31.svg" alt="Dragino LSN50v2-S31" width="400" /></p>
<figcaption>figure 5: Dragino LSN50v2-S31 LoRaWAN temperature and humidity sensor.</figcaption>
<hr />

<h3 id="connecting-a-new-lorawan-sensor">Connecting a new LoRaWAN sensor</h3>
<p>After the battery of the Dragino LSN50 sensor is inserted, the configuration
dashboard of the iQunet server shall display a new LoRaWAN device under the LoRa
Radio Module. The devEUI found on the LSN50 sensor should match the devEUI as
displayed in the dashboard.</p>

<p><img src="/tutorials/assets/images/iqunet-new-lorawan.svg" alt="iQunet Dashboard new LoRaWAN" /></p>
<figcaption>figure 6: The LoRaWAN sensor is detected and a new device LoRaWAN
device is created in the sensor tree.</figcaption>

<p>Communication with the sensor will not start until the encryption key is
set up. For this, click on the “Edit” button next to the <strong>Application Key</strong>
and fill in the 32-character key that comes with the Dragino Device.
The AppKey (also known as the JOIN key) is only used once during the setup of
the device.
<br /></p>

<p><img src="/tutorials/assets/images/iqunet-key-lorawan.svg" alt="iQunet LoRaWAN AppKey" /></p>
<figcaption>figure 7: Setup of the LoRaWAN Application Key in the dashboard.</figcaption>

<p>If the <strong>Application Key</strong> is correct, the sensor and the iQunet server will
generate 2 new session keys:</p>
<ul>
  <li>The <strong>Network Session Key</strong> (NwkSKey) is used for all communications related to
the LoRaWAN protocol (e.g. regional parameters and frequencies).</li>
  <li>The <strong>Application Session Key</strong> (AppSKey) is used for the exchange of sensor
data, in this particular case temperature and humidity.
<br /></li>
</ul>

<p><img src="/tutorials/assets/images/iqunet-sessionkeys-lorawan.svg" alt="iQunet LoRaWAN Session Keys" /></p>
<figcaption>figure 8: Secure Session keys are calculated from the Application Key.</figcaption>

<p>After all OTAA keys have been successfully set up, the actual <strong>uplink of
sensor data</strong> starts. The iQunet Server automatically detects the sensor model
and selects the corresponding <strong>payload decoder</strong> module. Binary sensor data is
now unpacked into the appropriate fields in the OPC-UA tree. The dashboard will
adjust and display all relevant information. For example, the LSN50v2-S31 will
transmit temperature, humidity and battery power, as shown in figure 9:
<br /></p>

<p><img src="/tutorials/assets/images/iqunet-lsn50.svg" alt="iQunet custom dashboard" /></p>
<figcaption>figure 9: Dashboard will adjust to the sensor type.</figcaption>

<p>When available, sensor settings can be adjusted via the <strong>LoRaWAN downlink</strong>
channel. For example, the LSN50 allows the on-the-fly setup of the measurement
interval. The configuration can be adjusted not only in the dashboard but also
programmatically via the OPC-UA, MQTT, or GraphQL interface. This allows for
<strong>automated provisioning</strong> of multiple sensors.</p>
<hr />

<h3 id="embedded-opc-ua-client">Embedded OPC-UA Client</h3>
<p>At this point, the sensor has successfully joined the private LoRaWAN network
and incoming measurements are stored into the <strong>local database</strong>. Historical
data can be retrieved via the OPC-UA “<strong>historical access</strong>” extension.</p>

<p>Click the OPC-UA tab in the dashboard to open the embedded OPC-UA browser,
as shown in figure 10:</p>

<p><img src="/tutorials/assets/images/iqunet-dashboard-opcua.svg" alt="iQunet OPC-UA browser" /></p>
<figcaption>figure 10: Embedded OPC-UA client and browser.</figcaption>
<hr />

<h3 id="uaexpert-opc-ua-client">UaExpert OPC-UA Client</h3>
<p>The server listens on all network interfaces (LAN, WLAN, wireguard VPN) at <strong>port 4840</strong>.</p>

<p>For example, when the ethernet cable is connected to LAN network 192.168.10.0/24:
<br /></p>

<table>
  <thead>
    <tr>
      <th>Service</th>
      <th>URL</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>WebServer</td>
      <td>http://192.168.10.101:8000/dashboard</td>
    </tr>
    <tr>
      <td>GraphQL server</td>
      <td>http://192.168.10.101:8000/graphql</td>
    </tr>
    <tr>
      <td><strong>OPC-UA server</strong></td>
      <td><strong>opc.tcp://192.168.10.101:4840</strong></td>
    </tr>
  </tbody>
</table>

<p>The OPC-UA server is also accessible by all third-party client software, such
as UaExpert, a popular OPC-UA client developed by Unified Automation
[<a href="https://www.unified-automation.com/products/development-tools/uaexpert.html">unified-automation.com</a>].</p>

<p>Figure 11 shows the configuration of UaExpert to connect to the iQunet OPC-UA
server at address 192.168.10.101, port 4840. Both encrypted and non-encrypted
connections are supported.</p>

<p><img src="/tutorials/assets/images/uaexpert-setup.svg" alt="UaExpert Setup" /></p>
<figcaption>figure 11: Unified Automation UaExpert OPC-UA client connection setup.</figcaption>

<p>When the UaExpert client is successfully connected to the iQunet OPC-UA server,
direct access is provided to all realtime measurements, metadata and historical
values as stored in the local database.</p>

<p><img src="/tutorials/assets/images/uaexpert-history.svg" alt="UaExpert History view" /></p>
<figcaption>figure 12: Unified Automation UaExpert OPC-UA client: history view.</figcaption>
<hr />

<h3 id="post-processing-opc-ua-data-with-python">Post-processing OPC-UA data with Python</h3>
<p>The next step in this tutorial is connecting to the OPC-UA server using the
Python programming language. This allows for flexible <strong>postprocessing</strong>, such
as smoothing data, sending automated alarm messages or creating your own custom
aggregate dashboards with realtime data.</p>

<p>Below is the boilerplate Python code to connect to the OPC-UA server, extract
the temperatures from the last day, and generate a basic plot.
Three external libraries are used for this:
<em><a href="https://pypi.org/project/asyncua/">opcua-asyncio</a></em>,
<em><a href="https://pypi.org/project/numpy/">numpy</a></em> and
<em><a href="https://pypi.org/project/matplotlib/">matplotlib</a></em>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">asyncua</span> <span class="kn">import</span> <span class="n">Client</span>

<span class="k">def</span> <span class="nf">moving_avg</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">window</span><span class="p">):</span>
    <span class="n">padded</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">pad</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="p">(</span><span class="n">window</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">window</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">window</span><span class="o">//</span><span class="mi">2</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s">'edge'</span><span class="p">)</span>
    <span class="n">window</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">ones</span><span class="p">(</span><span class="n">window</span><span class="p">)</span> <span class="o">/</span> <span class="n">window</span>
    <span class="n">smooth</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">padded</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">'valid'</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">smooth</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">url</span> <span class="o">=</span> <span class="s">'opc.tcp://192.168.10.101:4840'</span>
    <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="s">'0:Objects'</span><span class="p">,</span> <span class="s">'2:31:86:84:11'</span><span class="p">,</span> <span class="s">'2:boardTemperature'</span><span class="p">]</span>

    <span class="k">async</span> <span class="k">with</span> <span class="n">Client</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="n">url</span><span class="p">)</span> <span class="k">as</span> <span class="n">client</span><span class="p">:</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="n">nodes</span><span class="p">.</span><span class="n">root</span>
        <span class="n">node</span> <span class="o">=</span> <span class="k">await</span> <span class="n">root</span><span class="p">.</span><span class="n">get_child</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

        <span class="c1"># read history
</span>        <span class="n">start_time</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">.</span><span class="n">datetime</span><span class="p">.</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="n">datetime</span><span class="p">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">end_time</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">.</span><span class="n">datetime</span><span class="p">.</span><span class="n">now</span><span class="p">()</span>
        <span class="n">history</span> <span class="o">=</span> <span class="k">await</span> <span class="n">node</span><span class="p">.</span><span class="n">read_raw_history</span><span class="p">(</span><span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">)</span>

        <span class="c1"># Extracting values
</span>        <span class="n">times</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">.</span><span class="n">SourceTimestamp</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">history</span><span class="p">]</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">.</span><span class="n">Value</span><span class="p">.</span><span class="n">Value</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">history</span><span class="p">]</span>

        <span class="c1"># Smooth
</span>        <span class="n">smooth</span> <span class="o">=</span> <span class="n">moving_avg</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

        <span class="c1"># Plot
</span>        <span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span> <span class="s">''</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'o'</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">'Original'</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">smooth</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'-'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'red'</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">'Smoothed'</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Timestamp'</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'Value'</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Temperature'</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">asyncio</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>

</code></pre></div></div>

<p><img src="/tutorials/assets/images/temperature_plot.png" alt="Temperature Plot" /></p>
<figcaption>figure 13: Smoothed temperature plot using opcua-asyncio and matplotlib.</figcaption>
<hr />

<h3 id="conclusion">Conclusion</h3>
<p>Throughout this tutorial, we’ve demonstrated how to integrate a LoRaWAN sensor
with the iQunet Industrial Edge Server, store sensor data in a local OPC-UA
database, and visualize the data using Python. By following these steps, you
have successfully set up a <strong>private LoRaWAN network</strong> and accessed <strong>real-time
and historical data</strong> through the embedded OPC-UA server.</p>

<p>Beyond the basics covered in this guide, iQunet offers extensive capabilities
for more advanced data processing tasks. These include handling complex datasets
like vibration data, implementing machine learning techniques for predictive
maintenance, and enabling custom software adaptations for specific industrial
needs.</p>

<p><span style="background-color: #ffff0054">
For further exploration and support, check out our
<a href="https://iqunet.com/resources/"><strong>documentation</strong></a>, get new ideas from some
<a href="https://iqunet.com/resources/case-studies/case-study-1-international-airport/"><strong>case studies</strong></a>
or reach out to our <a href="https://iqunet.com/contact/"><strong>support team</strong></a>.
Happy data monitoring!
</span></p>]]></content><author><name>{&quot;avatar&quot;=&gt;&quot;/assets/images/iqunet_logo_bgwhite.svg&quot;, &quot;links&quot;=&gt;[{&quot;label&quot;=&gt;&quot;iQunet.com&quot;, &quot;icon&quot;=&gt;&quot;fas fa-fw fa-house&quot;, &quot;url&quot;=&gt;&quot;https://iqunet.com&quot;}, {&quot;label&quot;=&gt;&quot;LinkedIn&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-linkedin&quot;, &quot;url&quot;=&gt;&quot;https://linkedin.com/company/iqunet/&quot;}, {&quot;label&quot;=&gt;&quot;YouTube&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-youtube&quot;, &quot;url&quot;=&gt;&quot;https://www.youtube.com/channel/UCOPGTm7iW8Xh6ZJP8UBq_nQ&quot;}, {&quot;label&quot;=&gt;&quot;GitHub&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-github&quot;, &quot;url&quot;=&gt;&quot;https://iqunet.github.io/tutorials&quot;}]}</name></author><category term="blog" /><summary type="html"><![CDATA[Mission: LoRaWAN Temperature Data to Python Graph]]></summary></entry></feed>