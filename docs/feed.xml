<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.5">Jekyll</generator><link href="/tutorials/feed.xml" rel="self" type="application/atom+xml" /><link href="/tutorials/" rel="alternate" type="text/html" /><updated>2024-05-30T06:22:14-05:00</updated><id>/tutorials/feed.xml</id><title type="html">iQunet Tutorials: OPC-UA | MQTT | Modbus | LoRaWAN</title><subtitle>iQunet offers ready-to-use products for your digitalization projects, ensuring a quick rollout of your monitoring solutions.  We also support custom engineering requests to meet your specific needs.</subtitle><author><name>{&quot;avatar&quot;=&gt;&quot;/assets/images/iqunet_logo_bgwhite.svg&quot;, &quot;links&quot;=&gt;[{&quot;label&quot;=&gt;&quot;iQunet.com&quot;, &quot;icon&quot;=&gt;&quot;fas fa-fw fa-house&quot;, &quot;url&quot;=&gt;&quot;https://iqunet.com&quot;}, {&quot;label&quot;=&gt;&quot;LinkedIn&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-linkedin&quot;, &quot;url&quot;=&gt;&quot;https://linkedin.com/company/iqunet/&quot;}, {&quot;label&quot;=&gt;&quot;YouTube&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-youtube&quot;, &quot;url&quot;=&gt;&quot;https://www.youtube.com/channel/UCOPGTm7iW8Xh6ZJP8UBq_nQ&quot;}, {&quot;label&quot;=&gt;&quot;GitHub&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-github&quot;, &quot;url&quot;=&gt;&quot;https://iqunet.github.io/tutorials&quot;}]}</name></author><entry><title type="html">Modbus to MQTT</title><link href="/tutorials/blog/modbus-to-mqtt/" rel="alternate" type="text/html" title="Modbus to MQTT" /><published>2024-05-24T05:06:19-05:00</published><updated>2024-05-24T05:06:19-05:00</updated><id>/tutorials/blog/modbus-to-mqtt</id><content type="html" xml:base="/tutorials/blog/modbus-to-mqtt/"><![CDATA[<h3 id="mission-publish-modbus-over-mqtt-plot-in-python">Mission: Publish Modbus over MQTT, plot in Python</h3>

<p><img src="/tutorials/assets/images/modbus-mqtt-python.svg" alt="LoRaWAN to OPC UA" /></p>

<p><span style="background-color: #ffff0054">
<strong>Note:</strong> This tutorial uses the iQunet Industrial Edge Server
[<a href="https://iqunet.com/products/servers/">link</a>].
<br />A demo gateway endpoint is provided for the purpose of this guide.
</span></p>

<blockquote>
  <p><strong>Modbus</strong> is a wired communication protocol for industrial automation
and data exchange between devices like sensors and PLC controllers.
Visit <a href="https://modbus.org">modbus.org</a>.</p>

  <ul>
    <li><strong>Modbus-RTU:</strong> Uses serial wired communication (RS-232/RS-485) for
short-distance, point-to-point, or multi-drop connections.</li>
    <li><strong>Modbus-TCP:</strong> Runs over Ethernet, using TCP/IP for integration with
modern IT systems. A gateway is used to convert between Modbus-RTU and -TCP.</li>
  </ul>
</blockquote>

<blockquote>
  <p><strong>MQTT</strong> (Message Queuing Telemetry Transport) is a lightweight, publish-subscribe
network protocol designed for resource-constrained devices and low-bandwidth,
high-latency networks. It is widely used in internet-oriented services,
particularly for IoT applications. In contrast to OPC-UA, the payload format
is not part of the specification. Visit <a href="https://mqtt.org">mqtt.org</a>.</p>
</blockquote>

<p>In this tutorial, you will learn how to:</p>
<ul>
  <li>Connect a <strong>Modbus-RTU</strong> motor drive to the iQunet Industrial Edge Server.</li>
  <li>Understand the steps how sensor data is stored in the <strong>local OPC-UA database</strong>.</li>
  <li>Next, publish this sensor data in realtime to an <strong>MQTT broker</strong>.</li>
  <li>Subscribe to the MQTT broker using <strong>Python</strong> for post-processing and visualization.
<br /></li>
</ul>
<hr />

<h3 id="typical-modbus-to-mqtt-information-flow">Typical Modbus-to-MQTT Information Flow</h3>

<p>In a typical Modbus/MQTT monitoring setup, an industrial device,
<span>— </span>such as a <strong>motor drive</strong><span> —</span>
is connected to a <strong>Modbus-TCP gateway</strong> via an RS-485 serial interface.
The gateway converts between the synchronous Modbus-RTU protocol and the
asynchronous Modbus-TCP Ethernet network protocol. This allows the use of
standard networking equipment. Some devices natively support Modbus-TCP,
which eliminates the need for a gateway.</p>

<p><img src="/tutorials/assets/images/typical-modbus.svg" alt="Typical LoRaWAN setup" /></p>
<figcaption>figure 1: Typical Modbus to MQTT information flow</figcaption>

<p>A <strong>Modbus-TCP master</strong> actively polls connected devices to extract data, which
is subsequently decoded from binary to a user-friendly format, typically
JSON. This JSON data is then published to an MQTT platform, either on-premises
or cloud-based, such as the HiveMQ <strong>MQTT broker</strong>.</p>

<p>An <strong>MQTT subscriber</strong> retrieves the data from the broker and stores it in a database.
This database then serves as a data source for real-time or historical operational
dashboards, providing the user with insight into emerging faults, predictive
maintenance or energy efficiency.</p>

<p class="notice"><em>Configuring the Modbus-TCP master and decoding data demand deep understanding of
each device’s register map, requiring significant expertise and effort with every
new device integration.<br />
An example of such a manual setup procedure can be found here 
<a href="https://www.hivemq.com/blog/modbus-mqtt-integration-c-sharp-gateway-hivemq-mqtt-client/">hivemq.com <i style="margin: 0.2em; font-size: 0.7em" class="fa-solid fa-arrow-up-right-from-square"></i></a>.
<br />
<br />
The required expertise and effort may lead to a higher TCO and project delays
than initially projected, making a ready-to-use solution an attractive and efficient
alternative.</em></p>

<hr />

<h3 id="a-single-board-modbus-to-mqtt-setup">A Single-Board Modbus-to-MQTT Setup</h3>

<p>The Modbus-TCP gateway, Modbus master and MQTT publisher can all be integrated in
a single board computer (SBC), such as is the case for the iQunet Edge Server
[<a href="https://iqunet.com/products/servers/">link</a>].
Data collected via Modbus is first decoded and stored in the on-board <strong>OPC-UA historian
database</strong>.
<br />
This data can be routed (LAN/VPN) and accessed with the embedded dashboard
webserver or via various protocols, including OPC-UA, GraphQL or CSV. In a
second step, realtime updates in the OPC-UA server can be linked to the
onboard MQTT publisher for integration with third-party IoT platforms.
<br /></p>

<p><img src="/tutorials/assets/images/iqunet-modbus.svg" alt="iQunet LoRaWAN setup" /></p>
<figcaption>figure 2: iQunet single-server Modbus/MQTT gateway setup.</figcaption>

<p>In this tutorial, the <strong><span style="background-color:#ff9494">red route</span></strong>
indicated in figure 2 will be used. The motor drive is connected via an FTDI-232R
galvanically isolated interface to the iQunet Server, which polls the drive at a
configurable interval. The payload is then decoded, unpacked and written to the
<strong>built-in database</strong>.</p>

<h3 id="publishing-to-mqtt">Publishing to MQTT</h3>
<p>When a new measurement is written into the database, the OPC-UA server triggers
a callback that activates the MQTT publisher. The new measurement is first
converted into <strong>JSON format</strong> and published to the MQTT broker.<br />
The <strong>topic of the MQTT message</strong> is derived from the path of the corresponding
data point in the OPC-UA tree (figure 3).</p>

<p><img src="/tutorials/assets/images/iqunet-opcua-mqtt.svg" alt="iQunet OPC-UA" /></p>
<figcaption>figure 3: iQunet embedded OPC-UA server API</figcaption>

<p>In this tutorial, a Python program will then subscribe to the specified topic
on the MQTT broker and display the incoming data on a real-time updated graph.</p>
<hr />

<h3 id="motor-drive--modbus-hardware-setup">Motor Drive + Modbus Hardware Setup</h3>

<p>Figure 4 shows the minimal setup required to publish real-time motor drive data
via MQTT. This configuration includes the <strong>inverter drive</strong> itself, an (optional)
Ethernet <strong>network switch</strong>, the <strong>iQunet server</strong>, and a mobile <strong>access point</strong>,
which serves as a temporary placeholder for, for example, a company VLAN. The
Modbus-RTU to TCP gateway is omitted because the drive depicted in Figure 4 is
equipped with a Modbus-TCP communication module.</p>

<p>With this setup, MQTT data can be transmitted to either a private or a public
internet-based MQTT broker.</p>

<p><img src="/tutorials/assets/images/iqunet-setup-modbus.svg" alt="Modbus Example Hardware Setup" /></p>
<figcaption>figure 4: The setup with motor drive, iQunet server and access point.
</figcaption>

<p>For the remainder of this tutorial, the Invertek Optidrive E3 will be used.
The Optidrive inverter supports both Modbus-RTU and Modbus-TCP via an additional
module. However, because the Profinet IO module occupies the sole available slot
for PLC drive control, the on-board Modbus-RTU is used. A separate RS-485 to USB
converter is used for <strong>monitoring</strong> the drive parameters in <strong>read-only mode</strong>.
<br /></p>

<p><img src="/tutorials/assets/images/modbus-monitor-loop.svg" alt="Profinet Control and Modbus Monitor loop" /></p>
<figcaption>figure 5: Optidrive E3 - PLC control via Profinet and monitoring via Modbus-RTU.
</figcaption>
<hr />

<h3 id="scanning-for-modbus-devices">Scanning for Modbus Devices</h3>
<p>After the hardware is connected and powered up as shown in figure 4, the
Optidrive E3 must be added to the list of monitored devices in the iQunet
server software.</p>

<p>The first step involves activating both the Modbus-TCP and the Modbus-RTU modules
in the dashboard of the iQunet server. For this, click the Config button
<i style="margin: 0.2em; font-size: 0.7em" class="fa-solid fa-wrench"></i> in
the menu bar, as shown in Figure 6.</p>

<p><img src="/tutorials/assets/images/iqunet-modbus-enable.svg" alt="iQunet Enable Modbus in Dashboard" /></p>
<figcaption>figure 6: Enable the Modbus-TCP master and the Modbus-RTU gateway.</figcaption>

<ul>
  <li>The <strong>Modbus-TCP</strong> software module provides <strong>Modbus master</strong> functionality,
which includes probing the connected devices at regular intervals and forwarding
data to the OPC-UA historian database.</li>
  <li>The <strong>Modbus-RTU</strong> module enables the drivers for the FTDI FT232R USB-to-serial
interface and serves as a <strong>gateway</strong> for the Modbus master to communicate with
RTU devices.</li>
</ul>

<p>After both Modbus modules are enabled, the Home menu <i class="fa-solid fa-home"></i>
will display a new Modbus Master and Gateway node in the OPC-UA device list.</p>

<p>The Modbus Master allows <strong>scanning a single IP or subnet</strong> for known devices
(figure 7):</p>

<p><img src="/tutorials/assets/images/iqunet-modbus-tcp-scan.svg" alt="iQunet Modbus TCP Scanner" /></p>
<figcaption>figure 7: Scanning a LAN subnet for Modbus-TCP devices.</figcaption>

<p>The scanner is also capable of scanning not only for <strong>Modbus slave devices</strong> on
the <strong>local network</strong> (Ethernet or WiFi) but also for <strong>remote devices</strong> via any
configured <strong>Wireguard VPN</strong> endpoint on the iQunet server.</p>

<p>The <strong>Modbus-RTU gateway</strong> operates similarly, scanning all <strong>slave Unit IDs</strong>
within the configured range, as illustrated in Figure 8. Because Modbus-RTU is a
synchronous <strong>serial protocol</strong>, parallel scanning is not feasible. Therefore,
probing the full range of all slave IDs from 1 to 247 may take a minute or two.</p>

<p><img src="/tutorials/assets/images/iqunet-modbus-rtu-scan.svg" alt="iQunet Modbus RTU Scanner" /></p>
<figcaption>figure 7: Scanning all Unit IDs of a Modbus-RTU network.</figcaption>
<hr />

<h3 id="auto-detection-of-modbus-devices">Auto-Detection of Modbus Devices</h3>
<p>When the iQunet server detects a Modbus slave device on the network, it attempts
to identify the specifics of the slave for auto-configuration purposes. This
process serves two main objectives:</p>
<ul>
  <li><strong>Device Identification</strong>: A unique device MAC address is derived from the
device serial number. This allows for flexible remapping of IP addresses or
Unit (Slave) IDs, with monitoring data <strong>tied to the device serial</strong> rather than
the location in the network or the MAC address of the Modbus network card.</li>
  <li><strong>Device Type Detection</strong>: This is crucial for <strong>automatic payload decoding</strong>.
iQunet provides customized payload decoders upon request. The configuration
for the end-user is reduced to setting some basic parameters such as the
polling interval and the selection of data to be published to MQTT. This
<strong>simplifies the commissioning</strong> of new devices in the field, reducing the
setup time to a matter of minutes.</li>
</ul>

<p>In Figure 8 below, the <strong>Optidrive E3</strong> inverter is detected on the local
<strong>Modbus-RTU gateway</strong> at <strong>Unit ID 1</strong>. The dashboard automatically adapts to
the device specifics and displays the most important configuration highlights
of the device, such as the serial number, hardware model, and current
configuration (e.g., closed-loop <strong>vector control</strong> mode):</p>

<p><img src="/tutorials/assets/images/iqunet-optidrive-eco-status.svg" alt="iQunet Optidrive Eco dashboard" /></p>
<figcaption>figure 8: Auto-detection and configuration of the Modbus payload decoder.</figcaption>

<p>In addition to the static configuration, <strong>real-time drive</strong> and
<strong>historical parameters</strong> are also available in the dashboard. The generic motor
drive section (Figure 9) displays the most common parameters.</p>

<p><img src="/tutorials/assets/images/iqunet-optidrive-eco-monitor.svg" alt="iQunet Generic Motor drive monitor" /></p>
<figcaption>figure 9: Displaying real-time and historical drive parameters.</figcaption>

<p>While the dashboard provides a graphical summary of the drive status, much more
detailed information about drive parameters and historical logs can be accessed
by directly <strong>browsing the OPC-UA node tree</strong> of the internal OPC-UA server. To
do this, click the OPC-UA icon in the left menu:</p>

<p><img src="/tutorials/assets/images/iqunet-optidrive-eco-opcua-dashboard.svg" alt="iQunet OPC-UA browser" /></p>
<figcaption>figure 10: Accessing and exporting drive parameters via the OPC-UA browser.</figcaption>

<p>The built-in OPC-UA browser allows immediate export to <strong>Google Sheets</strong> or a
plain <strong>CSV file</strong>. Additionally, as shown in Figure 10, any variable node of the
OPC-UA tree can be enabled for <strong>publication via MQTT</strong> to an external broker.</p>
<hr />

<h3 id="direct-access-of-modbus-data-via-opc-ua">Direct Access of Modbus Data via OPC-UA</h3>
<p>All <strong>historical Modbus data</strong> is stored in the <strong>OPC-UA database</strong> of the iQunet
server. It can either be browsed via the dashboard of the web interface, or through
<strong>third-party OPC-UA clients</strong> such as UaExpert, a popular OPC-UA client developed
by Unified Automation
[<a href="https://www.unified-automation.com/products/development-tools/uaexpert.html">unified-automation.com</a>].</p>

<p>Figure 11 shows the configuration of UaExpert to connect to the iQunet OPC-UA
server at address 192.168.10.101, port 4840. Both encrypted and non-encrypted
connections are supported.</p>

<p><img src="/tutorials/assets/images/uaexpert-setup.svg" alt="UaExpert Setup" /></p>
<figcaption>figure 11: Unified Automation UaExpert OPC-UA client connection setup.</figcaption>

<p>When the <strong>UaExpert client</strong> is successfully connected to the <strong>iQunet OPC-UA server</strong>,
direct access is provided to all real-time motor drive parameters, metadata and
historical values as stored in the local database.</p>

<p><img src="/tutorials/assets/images/iqunet-optidrive-eco-opcua-uaexpert.svg" alt="UaExpert OPC-UA browser" /></p>
<figcaption>figure 12: Accessing historical data with the UaExpert OPC-UA client.</figcaption>
<hr />

<div class="notice">
  <h3 id="opc-ua-vs-mqtt-payload-format-and-data-types">OPC-UA vs MQTT: Payload Format and Data Types</h3>
  <p><strong>MQTT</strong> is a widely used protocol for large-scale, <strong>multi-site IoT deployments</strong>.
However, it does not define a specific data format. <strong>JSON</strong> is commonly used
as the payload encoding, but it lacks data type definitions for the payload,
and thus needs careful manual coordination between data publishers and
subscribers to ensure mutual compatibility.</p>

  <p>On the other hand, <strong>OPC-UA</strong> is highly suitable for low latency networks,
real-time data exchange, and has <strong>well-defined object type formatting</strong>.
It allows OPC-UA clients to autonomously resolve data type definitions without
user intervention. However, the protocol is currently not widely used in
internet-oriented big data platforms.</p>

  <p>For maximum flexibility, the iQunet server supports both protocols and employs
the following strategy to link the OPC-UA core system to the MQTT subsystem:</p>

  <ul>
    <li>The OPC-UA node <strong>tree path is used as the topic</strong> for publishing data via MQTT.
A user-definable “Root/” can be prepended to the path (default: server name).</li>
    <li>The <strong>JSON payload</strong> consists of a dictionary dump, which includes the
<strong>numerical, string, or array data</strong>, and the <strong>source-</strong> and <strong>serverTimestamp</strong>
in ISO-8601 format.</li>
  </ul>
</div>

<h3 id="enabling-the-mqtt-subsystem-for-the-iqunet-server">Enabling the MQTT Subsystem for the iQunet Server</h3>
<p>Enabling the MQTT subsystem for the iQunet server is straightforward.</p>

<ul>
  <li>Click on the <strong>MQTT icon</strong> in the left-hand menu.</li>
  <li>Fill in the <strong>MQTT broker host details</strong> and credentials.<br />
Optionally, set a custom <strong>Client ID</strong> (also serves as the root of the topics).</li>
  <li>If supported by the broker, select the <strong>TLS</strong> encryption option.<br />
Finally, toggle the button “MQTT OFF” to <strong>“MQTT ON”</strong>.</li>
  <li>If the <span style="background-color: #abffab"><strong>ONLINE</strong></span> icon is
highlighted, the setup is complete and operational.</li>
</ul>

<p><img src="/tutorials/assets/images/iqunet-mqtt-configuration.svg" alt="iQunet Server MQTT Configuration Menu" /></p>
<figcaption>figure 13: MQTT Configuration Menu in the iQunet Dashboard.</figcaption>

<p>The MQTT setup menu also displays a list of all published nodes and their
respective topics. To add a node to this list, browse to the desired node in
the OPC-UA tree and click the <strong>MQTT “publish”</strong> button.</p>

<p><img src="/tutorials/assets/images/iqunet-mqtt-addnode.svg" alt="iQunet Server MQTT Add Published Node" /></p>
<figcaption>figure 14: Publish a new node via MQTT in the iQunet Dashboard.</figcaption>

<h3 id="testing-the-mqtt-setup">Testing the MQTT Setup</h3>
<p>To verify the MQTT setup, a <strong>web-based MQTT client</strong> will be connected to the
broker to subscribe to the published data. Since browsers do not support raw
TCP sockets, the WebSocket port of the broker will be used.</p>

<p>First, open the <strong>HiveMQ MQTT Client</strong>
[<a href="https://www.hivemq.com/demos/websocket-client/">hivemq.com</a>], and setup the
broker host and TLS WebSocket port as below. Then click connect.</p>
<ul>
  <li><strong>host</strong>: broker.hivemq.com</li>
  <li><strong>port</strong>: 8884 (wss://)</li>
</ul>

<p><img src="/tutorials/assets/images/hivemq-mqtt-client.svg" alt="Connecting the HiveMQ MQTT demo client" /></p>
<figcaption>figure 15: Connect the HiveMQ MQTT client to wss://broker.hivemq.com.
</figcaption>

<p>Next, click <strong>“Add New Topic Subscription”</strong> and choose the topic to
subscribe to. Use a multilevel wildcard (#) to subscribe to all topics at once.
More information here [<a href="https://www.hivemq.com/blog/mqtt-essentials-part-5-mqtt-topics-best-practices/">hivemq.com</a>]</p>

<p>For example, if the topic published to by the iQunet Server is<br />
<code class="language-plaintext highlighter-rouge">SERN-dca632xxxxxx/Objects/b1:dd:1f:e9/inverterTemperature</code>,
then subscribe to<br />
<code class="language-plaintext highlighter-rouge">SERN-dca632xxxxxx/#</code> to capture all messages from this server.</p>

<p><img src="/tutorials/assets/images/hivemq-mqtt-subscribe.svg" alt="Subscribing the HiveMQ client to a topic" /></p>
<figcaption>Figure 16: Subscribing to a topic and viewing incoming JSON data.</figcaption>

<p>If the configuration is correct, JSON packets will start arriving as soon as
they are published by the iQunet Server!</p>
<hr />

<h3 id="subscribing-to-mqtt-and-plotting-with-python">Subscribing to MQTT and Plotting with Python</h3>
<p>This section provides Python boilerplate code to demonstrate how to subscribe
to the MQTT broker, receive data from the iQunet server, and visualize this
data in real-time.</p>

<video width="100%" controls="" loop="" autoplay="" muted="">
  <source src="/tutorials/assets/videos/test3.mp4" type="video/mp4" />
  Your browser does not support the video tag.
</video>

<p>The <a href="https://pypi.org/project/paho-mqtt/">Paho MQTT client</a> is used for handling
MQTT communication, and <a href="https://pypi.org/project/matplotlib/">Matplotlib</a>
is used for plotting the data.</p>

<ul>
  <li>
    <p><strong>MQTT Client Configuration</strong>: The Paho MQTT client connects to the HiveMQ
 broker at <code class="language-plaintext highlighter-rouge">broker.hivemq.com</code> on TCP/TLS port <code class="language-plaintext highlighter-rouge">8883</code> and subscribes to the
 specified topic where the iQunet server publishes data.</p>
  </li>
  <li>
    <p><strong>Message Handling</strong>: When a message is received, the <code class="language-plaintext highlighter-rouge">on_message</code> callback
 parses the JSON payload and appends the data to an in-memory <code class="language-plaintext highlighter-rouge">cache</code>.
 The <code class="language-plaintext highlighter-rouge">data_event</code> signals to the plotting thread that new data is available.</p>
  </li>
  <li>
    <p><strong>Plotting</strong>: The <code class="language-plaintext highlighter-rouge">update_plot</code> function retrieves data from the cache,
 extracts timestamps and values, and updates the plot. The <code class="language-plaintext highlighter-rouge">FuncAnimation</code>
 class from Matplotlib refreshes the plot every second.</p>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib.animation</span> <span class="kn">import</span> <span class="n">FuncAnimation</span>
<span class="kn">import</span> <span class="nn">paho.mqtt.client</span> <span class="k">as</span> <span class="n">mqtt</span>

<span class="c1"># MQTT setup
</span><span class="n">BROKER</span> <span class="o">=</span> <span class="s">'broker.hivemq.com'</span>
<span class="n">PORT</span> <span class="o">=</span> <span class="mi">8883</span>
<span class="n">TOPIC</span> <span class="o">=</span> <span class="s">'SERN-dca632c03aee/Objects/b1:dd:1f:e9/inverterTemperature'</span>

<span class="c1"># In-memory storage
</span><span class="n">cache</span> <span class="o">=</span> <span class="n">deque</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="mi">1024</span><span class="p">)</span>

<span class="c1"># Event to trigger plot updates
</span><span class="n">data_event</span> <span class="o">=</span> <span class="n">threading</span><span class="p">.</span><span class="n">Event</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">on_connect</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">userdata</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">properties</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'Connected with result code </span><span class="si">{</span><span class="n">rc</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="n">client</span><span class="p">.</span><span class="n">subscribe</span><span class="p">(</span><span class="n">TOPIC</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">on_message</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">userdata</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
    <span class="n">payload</span> <span class="o">=</span> <span class="n">json</span><span class="p">.</span><span class="n">loads</span><span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="n">payload</span><span class="p">)</span>
    <span class="n">cache</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
    <span class="n">data_event</span><span class="p">.</span><span class="nb">set</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">start_mqtt_loop</span><span class="p">():</span>
    <span class="n">client</span> <span class="o">=</span> <span class="n">mqtt</span><span class="p">.</span><span class="n">Client</span><span class="p">(</span><span class="n">mqtt</span><span class="p">.</span><span class="n">CallbackAPIVersion</span><span class="p">.</span><span class="n">VERSION2</span><span class="p">)</span>
    <span class="n">client</span><span class="p">.</span><span class="n">tls_set</span><span class="p">()</span>
    <span class="n">client</span><span class="p">.</span><span class="n">on_connect</span> <span class="o">=</span> <span class="n">on_connect</span>
    <span class="n">client</span><span class="p">.</span><span class="n">on_message</span> <span class="o">=</span> <span class="n">on_message</span>
    <span class="n">client</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">BROKER</span><span class="p">,</span> <span class="n">PORT</span><span class="p">,</span> <span class="n">keepalive</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
    <span class="n">client</span><span class="p">.</span><span class="n">loop_start</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">client</span>

<span class="k">def</span> <span class="nf">update_plot</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">ax</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">data_event</span><span class="p">.</span><span class="n">is_set</span><span class="p">():</span>
        <span class="n">time</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="n">c</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">datetime</span><span class="p">.</span><span class="n">fromisoformat</span><span class="p">(</span><span class="n">pl</span><span class="p">[</span><span class="s">'SourceTimestamp'</span><span class="p">])</span> <span class="k">for</span> <span class="n">pl</span> <span class="ow">in</span> <span class="n">c</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">pl</span><span class="p">[</span><span class="s">'Value'</span><span class="p">]</span> <span class="k">for</span> <span class="n">pl</span> <span class="ow">in</span> <span class="n">c</span><span class="p">]</span>

    <span class="n">ax</span><span class="p">.</span><span class="n">clear</span><span class="p">()</span>
    <span class="n">ax</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'o'</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">70</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="mi">45</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s">'right'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">bottom</span><span class="o">=</span><span class="mf">0.30</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Inverter Temperature'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Timestamp'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'degC'</span><span class="p">)</span>
    <span class="n">data_event</span><span class="p">.</span><span class="n">clear</span><span class="p">()</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">client</span> <span class="o">=</span> <span class="n">start_mqtt_loop</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">update_plot</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">ani</span> <span class="o">=</span> <span class="n">FuncAnimation</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">cache_frame_data</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">client</span><span class="p">.</span><span class="n">disconnect</span><span class="p">()</span>
</code></pre></div></div>

<hr />

<h3 id="conclusion">Conclusion</h3>
<p>In this tutorial, we’ve demonstrated how to integrate a <strong>Modbus-RTU</strong> motor drive
with the <strong>iQunet Industrial Edge Server</strong>, store sensor data in a <strong>local OPC-UA
database</strong>, publish this sensor data to an <strong>MQTT broker</strong>, and finally
<strong>visualize</strong> the data using Python for a <strong>real-time monitoring</strong> setup.</p>

<p>Beyond the basics covered in this guide, iQunet offers extensive capabilities
for more advanced data processing tasks. These include handling complex datasets
like vibration data, implementing machine learning techniques for predictive
maintenance, and enabling custom software adaptations for specific industrial
needs.</p>

<p><span style="background-color: #ffff0054">
For further exploration and support, check out our
<a href="https://iqunet.com/resources/"><strong>documentation</strong></a>, get new ideas from some
<a href="https://iqunet.com/resources/case-studies/case-study-1-international-airport/"><strong>case studies</strong></a>
or reach out to our <a href="https://iqunet.com/contact/"><strong>support team</strong></a>.
Happy data monitoring!
</span></p>]]></content><author><name>{&quot;avatar&quot;=&gt;&quot;/assets/images/iqunet_logo_bgwhite.svg&quot;, &quot;links&quot;=&gt;[{&quot;label&quot;=&gt;&quot;iQunet.com&quot;, &quot;icon&quot;=&gt;&quot;fas fa-fw fa-house&quot;, &quot;url&quot;=&gt;&quot;https://iqunet.com&quot;}, {&quot;label&quot;=&gt;&quot;LinkedIn&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-linkedin&quot;, &quot;url&quot;=&gt;&quot;https://linkedin.com/company/iqunet/&quot;}, {&quot;label&quot;=&gt;&quot;YouTube&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-youtube&quot;, &quot;url&quot;=&gt;&quot;https://www.youtube.com/channel/UCOPGTm7iW8Xh6ZJP8UBq_nQ&quot;}, {&quot;label&quot;=&gt;&quot;GitHub&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-github&quot;, &quot;url&quot;=&gt;&quot;https://iqunet.github.io/tutorials&quot;}]}</name></author><category term="blog" /><summary type="html"><![CDATA[Mission: Publish Modbus over MQTT, plot in Python]]></summary></entry><entry><title type="html">Private LoRaWAN to OPC-UA</title><link href="/tutorials/blog/connecting-sensors-opcua/" rel="alternate" type="text/html" title="Private LoRaWAN to OPC-UA" /><published>2024-05-19T15:10:15-05:00</published><updated>2024-05-19T15:10:15-05:00</updated><id>/tutorials/blog/connecting-sensors-opcua</id><content type="html" xml:base="/tutorials/blog/connecting-sensors-opcua/"><![CDATA[<h3 id="mission-lorawan-temperature-data-to-python-graph">Mission: LoRaWAN Temperature Data to Python Graph</h3>

<p><img src="/tutorials/assets/images/lora-opc-python.svg" alt="LoRaWAN to OPC UA" /></p>

<p><span style="background-color: #ffff0054">
<strong>Note:</strong> This tutorial uses the iQunet Industrial Edge Server
[<a href="https://iqunet.com/products/servers/">link <i style="margin: 0.2em; font-size: 0.7em" class="fa-solid fa-arrow-up-right-from-square"></i></a>].
<br />A demo gateway endpoint is provided for the purpose of this guide.
</span></p>

<blockquote>
  <p>LoRaWAN (Long Range Wide Area Network) is a wireless communication protocol
designed for low-power, long-range, and low-data-rate applications. This makes
it ideal for IoT devices. For more detailed information, visit
<a href="https://lora-alliance.org/about-lorawan/">lora-alliance.org</a>.
<br /></p>
</blockquote>

<blockquote>
  <p>OPC-UA (Open Platform Communications Unified Architecture)
is a machine-to-machine communication protocol for industrial automation
developed for secure, realtime data exchange. Visit
<a href="https://opcfoundation.org/about/opc-technologies/opc-ua/">opcfoundation.org</a>.</p>
</blockquote>

<p>You will learn how to:</p>
<ul>
  <li>Connect a <strong>LoRaWAN sensor</strong> to the iQunet Industrial Edge Server.</li>
  <li>Understand how sensor data is stored into the <strong>local OPC-UA database</strong>.</li>
  <li>Test the OPC-UA server connection using <strong>UaExpert</strong>.</li>
  <li>Use <strong>Python</strong> to connect to the OPC-UA server for post-processing and visualization.
<br /></li>
</ul>
<hr />

<h3 id="typical-lorawan-network-infrastructure">Typical LoRaWAN Network Infrastructure</h3>

<p>In a standard LoRaWAN setup, a sensor sends data to a <strong>gateway</strong>, which
then forwards the encrypted data to a <strong>network server</strong> via the internet.
The network server buffers the data and forwards it to an <strong>application server</strong>
via MQTT [<a href="https://mqtt.org/">mqtt.org</a>]. The application server decrypts and unpacks
the binary sensor data and stores the measurement in a database, where it can
be retrieved by, for example, <strong>dashboarding software</strong> for visualization.</p>

<p><img src="/tutorials/assets/images/typical-lora.svg" alt="Typical LoRaWAN setup" /></p>
<figcaption>figure 1: Typical LoRaWAN setup for large networks</figcaption>
<p>This multi-step process can be quite challenging for a simple one-time setup,
particularly when integrating software from different vendors.</p>
<hr />

<h3 id="a-single-board-private-lorawan-setup">A Single-Board Private LoRaWAN Setup</h3>

<p>The LoRaWAN gateway, network/application server and database can all be
integrated in a single device, such as is the case for the iQunet Edge Server
[<a href="https://iqunet.com/products/servers/">link</a>].
The result is a secure standalone LoRaWAN network which requires only a <strong>local
network</strong> (LAN) connection for API data access. Sensor data is immediately written
to the <strong>local database</strong> and can be accessed via various protocols: OPC-UA, GraphQL,
MQTT, CSV or the internal web interface.
<br /></p>

<p><img src="/tutorials/assets/images/iqunet-lora.svg" alt="iQunet LoRaWAN setup" /></p>
<figcaption>figure 2: iQunet single-server LoRaWAN setup for
medium size networks (e.g. 250 devices)</figcaption>
<p>In this tutorial, the <strong><span style="background-color:#ff9494">red route</span></strong>
indicated in figure 2 will be used. The iQunet Server will receive the
LoRaWAN packets via the attached <strong>LoRa concentrator</strong> radio module, <strong>decode
and unpack</strong> the payload and store the data in the <strong>built-in database</strong>.</p>

<h3 id="the-opc-ua-server-interface">The OPC-UA server interface</h3>

<p>After being written to the database, the data is made accessible via the 
<strong>embedded OPC-UA server</strong>.
Measurements related to a single LoRaWAN sensor are organized under the
corresponding DevEUI node of that sensor in the OPC-UA node tree (see figure 3).</p>

<p><img src="/tutorials/assets/images/iqunet-opcua.svg" alt="iQunet OPC-UA" /></p>
<figcaption>figure 3: iQunet embedded OPC-UA server API</figcaption>
<hr />

<h3 id="lorawan-hardware-setup">LoRaWAN Hardware Setup</h3>

<p>Figure 4 shows a modular setup for a <strong>private LoRaWAN network</strong>. It consists
of an <strong>SX1302 LoRa Radio</strong> receiver, an iQunet Edge SBC (database and OPC-UA
server) and an (optional) 4G mobile router. The router is the temporary
placeholder for -for example- a company VLAN.</p>

<p><img src="/tutorials/assets/images/iqunet-setup.svg" alt="iQunet Base Setup" /></p>
<figcaption>figure 4: The setup with SX1302 concentrator module,
OPC-UA server and mobile network</figcaption>

<p>For the purpose of this tutorial, the Dragino LSN50v2-S31 temperature and
humidity LoRaWAN sensor will be used. Both the LSN50 and the iQunet server
understand the OTAA (over-the-air activation) protocol v1.0.4. OTAA allows to
automatically generate and exchange the network and application security keys
between sensor and the target application.
<br /></p>

<p><img src="/tutorials/assets/images/lsn50v2-s31.svg" alt="Dragino LSN50v2-S31" width="400" /></p>
<figcaption>figure 5: Dragino LSN50v2-S31 LoRaWAN temperature and humidity sensor.</figcaption>
<hr />

<h3 id="connecting-a-new-lorawan-sensor">Connecting a new LoRaWAN sensor</h3>
<p>After the battery of the Dragino LSN50 sensor is inserted, the configuration
dashboard of the iQunet server shall display a new LoRaWAN device under the LoRa
Radio Module. The devEUI found on the LSN50 sensor should match the devEUI as
displayed in the dashboard.</p>

<p><img src="/tutorials/assets/images/iqunet-new-lorawan.svg" alt="iQunet Dashboard new LoRaWAN" /></p>
<figcaption>figure 6: The LoRaWAN sensor is detected and a new device LoRaWAN
device is created in the sensor tree.</figcaption>

<p>Communication with the sensor will not start until the encryption key is
set up. For this, click on the “Edit” button next to the <strong>Application Key</strong>
and fill in the 32-character key that comes with the Dragino Device.
The AppKey (also known as the JOIN key) is only used once during the setup of
the device.
<br /></p>

<p><img src="/tutorials/assets/images/iqunet-key-lorawan.svg" alt="iQunet LoRaWAN AppKey" /></p>
<figcaption>figure 7: Setup of the LoRaWAN Application Key in the dashboard.</figcaption>

<p>If the <strong>Application Key</strong> is correct, the sensor and the iQunet server will
generate 2 new session keys:</p>
<ul>
  <li>The <strong>Network Session Key</strong> (NwkSKey) is used for all communications related to
the LoRaWAN protocol (e.g. regional parameters and frequencies).</li>
  <li>The <strong>Application Session Key</strong> (AppSKey) is used for the exchange of sensor
data, in this particular case temperature and humidity.
<br /></li>
</ul>

<p><img src="/tutorials/assets/images/iqunet-sessionkeys-lorawan.svg" alt="iQunet LoRaWAN Session Keys" /></p>
<figcaption>figure 8: Secure Session keys are calculated from the Application Key.</figcaption>

<p>After all OTAA keys have been successfully set up, the actual <strong>uplink of
sensor data</strong> starts. The iQunet Server automatically detects the sensor model
and selects the corresponding <strong>payload decoder</strong> module. Binary sensor data is
now unpacked into the appropriate fields in the OPC-UA tree. The dashboard will
adjust and display all relevant information. For example, the LSN50v2-S31 will
transmit temperature, humidity and battery power, as shown in figure 9:
<br /></p>

<p><img src="/tutorials/assets/images/iqunet-lsn50.svg" alt="iQunet custom dashboard" /></p>
<figcaption>figure 9: Dashboard will adjust to the sensor type.</figcaption>

<p>When available, sensor settings can be adjusted via the <strong>LoRaWAN downlink</strong>
channel. For example, the LSN50 allows the on-the-fly setup of the measurement
interval. The configuration can be adjusted not only in the dashboard but also
programmatically via the OPC-UA, MQTT, or GraphQL interface. This allows for
<strong>automated provisioning</strong> of multiple sensors.</p>
<hr />

<h3 id="embedded-opc-ua-client">Embedded OPC-UA Client</h3>
<p>At this point, the sensor has successfully joined the private LoRaWAN network
and incoming measurements are stored into the <strong>local database</strong>. Historical
data can be retrieved via the OPC-UA “<strong>historical access</strong>” extension.</p>

<p>Click the OPC-UA tab in the dashboard to open the embedded OPC-UA browser,
as shown in figure 10:</p>

<p><img src="/tutorials/assets/images/iqunet-dashboard-opcua.svg" alt="iQunet OPC-UA browser" /></p>
<figcaption>figure 10: Embedded OPC-UA client and browser.</figcaption>
<hr />

<h3 id="uaexpert-opc-ua-client">UaExpert OPC-UA Client</h3>
<p>The server listens on all network interfaces (LAN, WLAN, wireguard VPN) at <strong>port 4840</strong>.</p>

<p>For example, when the ethernet cable is connected to LAN network 192.168.10.0/24:
<br /></p>

<table>
  <thead>
    <tr>
      <th>Service</th>
      <th>URL</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>WebServer</td>
      <td>http://192.168.10.101:8000/dashboard</td>
    </tr>
    <tr>
      <td>GraphQL server</td>
      <td>http://192.168.10.101:8000/graphql</td>
    </tr>
    <tr>
      <td><strong>OPC-UA server</strong></td>
      <td><strong>opc.tcp://192.168.10.101:4840</strong></td>
    </tr>
  </tbody>
</table>

<p>The OPC-UA server is also accessible by all third-party client software, such
as UaExpert, a popular OPC-UA client developed by Unified Automation
[<a href="https://www.unified-automation.com/products/development-tools/uaexpert.html">unified-automation.com</a>].</p>

<p>Figure 11 shows the configuration of UaExpert to connect to the iQunet OPC-UA
server at address 192.168.10.101, port 4840. Both encrypted and non-encrypted
connections are supported.</p>

<p><img src="/tutorials/assets/images/uaexpert-setup.svg" alt="UaExpert Setup" /></p>
<figcaption>figure 11: Unified Automation UaExpert OPC-UA client connection setup.</figcaption>

<p>When the UaExpert client is successfully connected to the iQunet OPC-UA server,
direct access is provided to all realtime measurements, metadata and historical
values as stored in the local database.</p>

<p><img src="/tutorials/assets/images/uaexpert-history.svg" alt="UaExpert History view" /></p>
<figcaption>figure 12: Unified Automation UaExpert OPC-UA client: history view.</figcaption>
<hr />

<h3 id="post-processing-opc-ua-data-with-python">Post-processing OPC-UA data with Python</h3>
<p>The next step in this tutorial is connecting to the OPC-UA server using the
Python programming language. This allows for flexible <strong>postprocessing</strong>, such
as smoothing data, sending automated alarm messages or creating your own custom
aggregate dashboards with realtime data.</p>

<p>Below is the boilerplate Python code to connect to the OPC-UA server, extract
the temperatures from the last day, and generate a basic plot.
Three external libraries are used for this:
<em><a href="https://pypi.org/project/asyncua/">opcua-asyncio</a></em>,
<em><a href="https://pypi.org/project/numpy/">numpy</a></em> and
<em><a href="https://pypi.org/project/matplotlib/">matplotlib</a></em>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">asyncua</span> <span class="kn">import</span> <span class="n">Client</span>

<span class="k">def</span> <span class="nf">moving_avg</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">window</span><span class="p">):</span>
    <span class="n">padded</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">pad</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="p">(</span><span class="n">window</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">window</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">window</span><span class="o">//</span><span class="mi">2</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s">'edge'</span><span class="p">)</span>
    <span class="n">window</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">ones</span><span class="p">(</span><span class="n">window</span><span class="p">)</span> <span class="o">/</span> <span class="n">window</span>
    <span class="n">smooth</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">padded</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">'valid'</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">smooth</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">url</span> <span class="o">=</span> <span class="s">'opc.tcp://192.168.10.101:4840'</span>
    <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="s">'0:Objects'</span><span class="p">,</span> <span class="s">'2:31:86:84:11'</span><span class="p">,</span> <span class="s">'2:boardTemperature'</span><span class="p">]</span>

    <span class="k">async</span> <span class="k">with</span> <span class="n">Client</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="n">url</span><span class="p">)</span> <span class="k">as</span> <span class="n">client</span><span class="p">:</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="n">nodes</span><span class="p">.</span><span class="n">root</span>
        <span class="n">node</span> <span class="o">=</span> <span class="k">await</span> <span class="n">root</span><span class="p">.</span><span class="n">get_child</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

        <span class="c1"># read history
</span>        <span class="n">start_time</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">.</span><span class="n">datetime</span><span class="p">.</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="n">datetime</span><span class="p">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">end_time</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">.</span><span class="n">datetime</span><span class="p">.</span><span class="n">now</span><span class="p">()</span>
        <span class="n">history</span> <span class="o">=</span> <span class="k">await</span> <span class="n">node</span><span class="p">.</span><span class="n">read_raw_history</span><span class="p">(</span><span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">)</span>

        <span class="c1"># Extracting values
</span>        <span class="n">times</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">.</span><span class="n">SourceTimestamp</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">history</span><span class="p">]</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">.</span><span class="n">Value</span><span class="p">.</span><span class="n">Value</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">history</span><span class="p">]</span>

        <span class="c1"># Smooth
</span>        <span class="n">smooth</span> <span class="o">=</span> <span class="n">moving_avg</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

        <span class="c1"># Plot
</span>        <span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span> <span class="s">''</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'o'</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">'Original'</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">smooth</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'-'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'red'</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">'Smoothed'</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Timestamp'</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'Value'</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Temperature'</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">asyncio</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>

</code></pre></div></div>

<p><img src="/tutorials/assets/images/temperature_plot.png" alt="Temperature Plot" /></p>
<figcaption>figure 13: Smoothed temperature plot using opcua-asyncio and matplotlib.</figcaption>
<hr />

<h3 id="conclusion">Conclusion</h3>
<p>Throughout this tutorial, we’ve demonstrated how to integrate a LoRaWAN sensor
with the iQunet Industrial Edge Server, store sensor data in a local OPC-UA
database, and visualize the data using Python. By following these steps, you
have successfully set up a <strong>private LoRaWAN network</strong> and accessed <strong>real-time
and historical data</strong> through the embedded OPC-UA server.</p>

<p>Beyond the basics covered in this guide, iQunet offers extensive capabilities
for more advanced data processing tasks. These include handling complex datasets
like vibration data, implementing machine learning techniques for predictive
maintenance, and enabling custom software adaptations for specific industrial
needs.</p>

<p><span style="background-color: #ffff0054">
For further exploration and support, check out our
<a href="https://iqunet.com/resources/"><strong>documentation</strong></a>, get new ideas from some
<a href="https://iqunet.com/resources/case-studies/case-study-1-international-airport/"><strong>case studies</strong></a>
or reach out to our <a href="https://iqunet.com/contact/"><strong>support team</strong></a>.
Happy data monitoring!
</span></p>]]></content><author><name>{&quot;avatar&quot;=&gt;&quot;/assets/images/iqunet_logo_bgwhite.svg&quot;, &quot;links&quot;=&gt;[{&quot;label&quot;=&gt;&quot;iQunet.com&quot;, &quot;icon&quot;=&gt;&quot;fas fa-fw fa-house&quot;, &quot;url&quot;=&gt;&quot;https://iqunet.com&quot;}, {&quot;label&quot;=&gt;&quot;LinkedIn&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-linkedin&quot;, &quot;url&quot;=&gt;&quot;https://linkedin.com/company/iqunet/&quot;}, {&quot;label&quot;=&gt;&quot;YouTube&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-youtube&quot;, &quot;url&quot;=&gt;&quot;https://www.youtube.com/channel/UCOPGTm7iW8Xh6ZJP8UBq_nQ&quot;}, {&quot;label&quot;=&gt;&quot;GitHub&quot;, &quot;icon&quot;=&gt;&quot;fab fa-fw fa-github&quot;, &quot;url&quot;=&gt;&quot;https://iqunet.github.io/tutorials&quot;}]}</name></author><category term="blog" /><summary type="html"><![CDATA[Mission: LoRaWAN Temperature Data to Python Graph]]></summary></entry></feed>